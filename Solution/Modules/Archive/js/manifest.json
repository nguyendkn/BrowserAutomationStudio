{
    "actions": [
        {
            "code": [
                {
                    "file": "Archive_Unpack_code.js",
                    "name": "Archive_Unpack_code"
                }
            ],
            "description": {
                "en": "Unpack archive",
                "ru": "Распаковать архив"
            },
            "interface": "Archive_Unpack_interface.js",
            "is_element": false,
            "name": "Archive_Unpack",
            "select": "Archive_Unpack_select.js",
            "template": "{{ArchivePath}} -> {{DestinationPath}}"
        },
		{
            "code": [
                {
                    "file": "Archive_GetFileList_code.js",
                    "name": "Archive_GetFileList_code"
                }
            ],
            "description": {
                "en": "Get file list from archive",
                "ru": "Получить список файлов из архива"
            },
            "interface": "Archive_GetFileList_interface.js",
            "is_element": false,
            "name": "Archive_GetFileList",
            "select": "Archive_GetFileList_select.js",
            "template": "{{ArchivePath}} -> {{Save}}"
        }
    ],
    "api_version": 1,
    "autogenerated_functions": [
        "Archive_Unpack",
		"Archive_GetFileList"
    ],
    "browser": [
    ],
    "depends": [
    ],
    "description": "Working with archives",
    "description_small": {
        "en": "Archive",
        "ru": "Архив"
    },
    "developer_email": "sasha9817@mail.ru",
    "developer_name": "GhostZ",
    "developer_site": "https://t.me/GhostZed",
    "embeddeddata": [
        {
            "Data": "const unzipper = require(\"unzipper\");\r\nconst fs = require('fs');\r\nconst il = require('iconv-lite');\r\n\r\nvar archive_path = [[ARCHIVE_ARCHIVE_PATH]];\r\nvar list_of_files = [];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    var readStream = fs.createReadStream(archive_path);\r\n    readStream.on(\"error\", function error(e) {\r\n        reject(e);\r\n    });\r\n    var parse = readStream.pipe(unzipper.Parse());\r\n    parse.on('entry', function (entry){\r\n        var isUnicode = entry.props.flags.isUnicode;\r\n        var filePath = isUnicode ? entry.path : il.decode(entry.props.pathBuffer, 'cp866');\r\n        list_of_files.push(filePath);\r\n        var autodrain = entry.autodrain();\r\n        autodrain.on(\"error\", function error(e) {\r\n            reject(e);\r\n        });\r\n    });\r\n    parse.on(\"error\", function error(e) {\r\n        reject(e);\r\n    });\r\n    parse.on(\"close\", function close() {\r\n        [[ARCHIVE_LIST_OF_FILES]] = list_of_files;\r\n        resolve();\r\n    });\r\n}));",
            "DataName": "8blehxhq8o7",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "8.6.0"
        },
        {
            "Data": "const fs = require('fs');\r\nconst path = require('path');\r\nconst unzipper = require(\"unzipper\");\r\nconst il = require('iconv-lite');\r\n\r\nvar archive_path = [[ARCHIVE_UNPACK_PARAMETERS]][0];\r\nvar destination_path = [[ARCHIVE_UNPACK_PARAMETERS]][1];\r\nvar list_of_files = [[ARCHIVE_UNPACK_PARAMETERS]][2];\r\nvar unpack_all = list_of_files.length<=0;\r\n\r\nfunction ensureDirectoryExistence(filePath) {\r\n    var dirname = path.dirname(filePath);\r\n    if(fs.existsSync(dirname)){\r\n        return true;\r\n    };\r\n    ensureDirectoryExistence(dirname);\r\n    fs.mkdirSync(dirname);\r\n};\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    var readStream = fs.createReadStream(archive_path);\r\n    readStream.on(\"error\", function error(e) {\r\n        reject(e);\r\n    });\r\n    var parse = readStream.pipe(unzipper.Parse());\r\n    parse.on('entry', function (entry){\r\n        var isUnicode = entry.props.flags.isUnicode;\r\n        var filePath = isUnicode ? entry.path : il.decode(entry.props.pathBuffer, 'cp866');\r\n        var fullPath = destination_path + '/' + filePath;\r\n        var fileType = entry.type;\r\n        if(unpack_all || list_of_files.indexOf(filePath) > -1){\r\n            if(fileType===\"File\"){\r\n                ensureDirectoryExistence(fullPath);\r\n                var writeStream = entry.pipe(fs.createWriteStream(fullPath));\r\n                writeStream.on(\"error\", function error(e) {\r\n                    reject(e);\r\n                });\r\n            }else{\r\n                fs.mkdirSync(fullPath);\r\n                var autodrain = entry.autodrain();\r\n                autodrain.on(\"error\", function error(e) {\r\n                    reject(e);\r\n                });\r\n            }\r\n        }else{\r\n            var autodrain = entry.autodrain();\r\n            autodrain.on(\"error\", function error(e) {\r\n                reject(e);\r\n            });\r\n        };\r\n    });\r\n    parse.on(\"error\", function error(e) {\r\n        reject(e);\r\n    });\r\n    parse.on(\"close\", function close() {\r\n        resolve();\r\n    });\r\n}));",
            "DataName": "a4frny5450e",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "8.6.0"
        }
    ],
    "engine": [
        "engine.js"
    ],
    "icon": "Archive.png",
    "info": {
        "en": "Module for working with archives",
        "ru": "Модуль для работы с архивами"
    },
    "is_autogenerated": true,
    "languages": [
        {
            "Name": "Node",
            "Version": "8.6.0"
        }
    ],
    "localize": {
		"is empty": {"ru":"пуст"},
		"Archive type": {"ru":"Тип архива"},
		"Archive path": {"ru":"Путь к архиву"},
		"List of files": {"ru":"Список файлов"},
		"Can be blank": {"ru":"Может быть пустым"},
		"Destination path": {"ru":"Путь назначения"},
		"The place in which the archive": {"ru":"Место в котором находится архив"},
		"The archive will be completely unpacked": {"ru":"Архив будет распакован полностью"},
		"This action only works with zip archives.": {"ru":"Данное действие работает только с zip архивами."},
		"Get a list of files contained in the archive.": {"ru":"Получить список файлов содержащихся в архиве."},
		"The path to the archive which needs to be unpacked.": {"ru":"Путь к архиву который нужно распаковать."},
		"The archive type will be determined by the file extension": {"ru":"Тип архива будет определен по расширению файла"},
		"Unpack the contents of the archive to the specified location.": {"ru":"Распаковать содержимое архива в указанное место."},
		"The path to the archive from which needs to get the list of files.": {"ru":"Путь к архиву из которого нужно получить список файлов."},
		"The path to the location where the contents of the archive will be unpacked.": {"ru":"Путь к месту в которое будет распаковано содержимое архива."},		
		"Variable in which, after successful completion of the action, will be recorded list of files contained in the archive.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записан список файлов содержащихся в архиве."},
		"If the destination path is not specified, the archive will be unpacked to the location where it is located.": {"ru":"Если путь назначения не указан, архив будет распаковать в то место в котором он находится."},
		"This action can unpack not the entire archive, but only a part of it, for this you need to specify a list of files that need to be unpacked.": {"ru":"Данное действие может распаковывать не весь архив, а только его часть, для этого нужно указать список файлов которые нужно распоковать."},
		"The archive type is usually written in the file extension. But there are exceptions, such as Chrome extensions files have the extension .crx, but are zip archive with additional headers.": {"ru":"Тип архива обычно пишется в расширении файла. Но бывают и исключения, например файлы расширений Chrome имеют расширение .crx, но являются zip архивом с дополнительными заголовками."},
		"List of files to extract from the archive. The list of files can be obtained using the \"Get file list from archive\" action. If this parameter is not specified, the archive will be completely unpacked.": {"ru":"Список файлов которые нужно извлечь из архива. Список файлов можно получить с помощь действия \"Получить список файлов из архива\". Если данный параметр не указан архив будет распокован полностью."}
    },
    "major_version": 1,
    "minor_version": 0,
    "modules": [
        {
            "LanguageName": "Node",
            "LanguageVersion": "8.6.0",
            "ModuleName": "unzipper",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "8.6.0",
            "ModuleName": "iconv-lite",
            "ModuleVersion": "*"
        }
    ],
    "name": "Archive"
}
