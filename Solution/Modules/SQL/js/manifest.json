{
    "actions": [
		{
            "code": [
                {
                    "file": "SQL_Setup_code.js",
                    "name": "SQL_Setup_code"
                }
            ],
            "description": {
                "en": "Setup connection",
                "ru": "Настроить соединение"
            },
            "interface": "SQL_Setup_interface.js",
            "is_element": false,
            "name": "SQL_Setup",
            "select": "SQL_Setup_select.js",
            "template": "{{dialect}}:{{host}}:{{storage}}"
        },
        {
            "code": [
                {
                    "file": "SQL_Query_code.js",
                    "name": "SQL_Query_code"
                }
            ],
            "description": {
                "en": "Execute query",
                "ru": "Выполнить запрос"
            },
            "interface": "SQL_Query_interface.js",
            "is_element": false,
            "name": "SQL_Query",
            "select": "SQL_Query_select.js",
            "template": "{{query}}"
        },
		{
            "code": [
                {
                    "file": "SQL_SelectRecord_code.js",
                    "name": "SQL_SelectRecord_code"
                }
            ],
            "description": {
                "en": "Select single record",
                "ru": "Получить одну запись"
            },
            "interface": "SQL_SelectRecord_interface.js",
            "is_element": false,
            "name": "SQL_SelectRecord",
            "select": "SQL_SelectRecord_select.js",
            "template": "{{table}}"
        },
		{
            "code": [
                {
                    "file": "SQL_SelectRecords_code.js",
                    "name": "SQL_SelectRecords_code"
                }
            ],
            "description": {
                "en": "Select multiple records",
                "ru": "Получить несколько записей"
            },
            "interface": "SQL_SelectRecords_interface.js",
            "is_element": false,
            "name": "SQL_SelectRecords",
            "select": "SQL_SelectRecords_select.js",
            "template": "{{table}}"
        },
        {
            "code": [
                {
                    "file": "SQL_Close_code.js",
                    "name": "SQL_Close_code"
                }
            ],
            "description": {
                "en": "Close connection",
                "ru": "Закрыть соединение"
            },
            "interface": "SQL_Close_interface.js",
            "is_element": false,
            "name": "SQL_Close",
            "select": "SQL_Close_select.js",
            "template": ""
        }
    ],
    "api_version": 1,
    "autogenerated_functions": [
        "SQL_Setup",
        "SQL_Query",
		"SQL_SelectRecord",
		"SQL_SelectRecords",
        "SQL_Close"
    ],
    "browser": [
    ],
    "depends": [
    ],
    "description": "Working with SQL databases",
    "description_small": {
        "en": "SQL",
        "ru": "SQL"
    },
    "developer_email": "sasha9817@mail.ru",
    "developer_name": "GhostZ",
    "developer_site": "https://t.me/GhostZed",
    "embeddeddata": [
        {
            "Data": "const Sequelize = require('sequelize');\nconst SqlString = require('sequelize/lib/sql-string');\nvar self = this;\n\nthis.connect_sql = async function(id, config){\n    var dialect = config.dialect;\n\n    if(typeof sql_connections==\"undefined\"){\n        sql_connections = {};\n    };\n\n    if(typeof sql_connections[id]==\"undefined\"){\n        sql_connections[id] = {};\n    };\n\n    if(typeof sql_connections[id][dialect]==\"undefined\" || JSON.stringify(sql_connections[id][dialect].config)!=JSON.stringify(config)){\n        var options = {};\n        var keys = Object.keys(config);\n        for(var key of keys){\n            if(config[key]!=\"\" && key!=\"storage\"){\n                options[key] = config[key];\n            };\n        };\n        if(dialect===\"sqlite\"){\n            if(config.storage){\n                options.storage = config.storage;\n            };\n            options.dialectModule = require('sqlite3-offline').verbose();\n        };\n        options.define = {freezeTableName: true};\n        sql_connections[id][dialect] = {\n            id: id,\n            dialect: dialect,\n            config: config,\n            sequelize: new Sequelize(options),\n            timeout: 0,\n            close: function(id, dialect){\n                if(typeof sql_connections!=\"undefined\" && typeof sql_connections[id]!=\"undefined\" && typeof sql_connections[id][dialect]!=\"undefined\"){\n                    var sql = sql_connections[id][dialect];\n                    sql.sequelize.close();\n                    return sql.delete();\n                };\n            },\n            setTimeout: function(timeout){\n                this.clearTimeout();\n                this.timeout = setTimeout(this.close, timeout, this.id, this.dialect);\n            },\n            clearTimeout: function(){\n                if(!this.timeout[\"_destroyed\"]){\n                    clearTimeout(this.timeout);\n                };\n            },\n            delete: function(){delete sql_connections[this.id][this.dialect]}\n        };\n        var sql_obj = sql_connections[id][dialect];\n        try{\n            await sql_obj.sequelize.authenticate();\n            return sql_obj;\n        }catch(err){\n            sql_obj.delete();\n            throw err;\n        };\n    }else{\n        sql_connections[id][dialect].clearTimeout();\n        if(typeof sql_connections==\"undefined\" || typeof sql_connections[id]==\"undefined\" || typeof sql_connections[id][dialect]==\"undefined\"){\n            var sql_obj = await self.connect_sql(id, config);\n            return sql_obj;\n        }else{\n            return sql_connections[id][dialect];\n        };\n    };\n};\nthis.get_model = async function(sequelize, table){\n    var models = sequelize.models;\n    if(Object.keys(models).indexOf(table) > -1){\n        return models[table];\n    }else{\n        var QueryInterface = sequelize.getQueryInterface();\n        var schema = await QueryInterface.describeTable(table);\n        schema[Object.keys(schema)[0]][\"primaryKey\"] = true;\n        var model = sequelize.define(table, schema, {timestamps: false});\n        await model.sync();\n        return model;\n    };\n};\nthis.format = function(sql, replacements, dialect){\n    return SqlString.format(sql, replacements, null, dialect);\n};\nthis.restore_dates = function(values){\n    values = [].concat(values);\n    return values.map(function(value){return value.isDate ? new Date(value.date) : (Array.isArray(value) ? value.map(function(e){return e.isDate ? new Date(e.date) : e}) : value)});\n};",
            "DataName": "UtilSQL",
            "DataType": 1,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilSQL\");\r\n\r\nvar [id, config, timeout, query_sql, query_type, parameterize, replacements] = [[SQL_NODE_PARAMETERS]];\r\n\r\nvar options = {type:query_type};\r\nif(parameterize){\r\n    options.replacements = util.restore_dates(replacements);\r\n};\r\n\r\nvar sql = await util.connect_sql(id, config);\r\ntry{\r\n    var sequelize = sql.sequelize;\r\n    var results = await sequelize.query(query_sql, options);\r\n    if(query_type==\"RAW\"){\r\n        var res = results[0];\r\n        var met = results[1];\r\n        results = [res!=null ? res : \"\", met!=null ? met : \"\"];\r\n    }else{\r\n        results = [results!=null ? results : \"\", \"\"];\r\n    };\r\n    [[SQL_NODE_PARAMETERS]] = results;\r\n    sql.setTimeout(timeout);\r\n}catch(err){\r\n    sql.setTimeout(timeout);\r\n    throw err;\r\n};",
            "DataName": "SQL_Query",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "var id = [[SQL_NODE_PARAMETERS]];\r\n\r\nif(typeof sql_connections!=\"undefined\" || typeof sql_connections[id]!=\"undefined\"){\r\n    var dialects = Object.keys(sql_connections[id]);\r\n    for(let dialect of dialects){\r\n        var sql = sql_connections[id][dialect];\r\n        sql.close(id, dialect);\r\n    };\r\n};",
            "DataName": "SQL_Close",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilSQL\");\r\n\r\nvar [id, config, timeout, table, where, included_columns, excluded_columns, order, offset, limit, parameterize, replacements] = [[SQL_NODE_PARAMETERS]];\r\n\r\nif(parameterize){\r\n    replacements = util.restore_dates(replacements);\r\n    where = util.format(where, replacements, config.dialect);\r\n};\r\n\r\nvar sql = await util.connect_sql(id, config);\r\ntry{\r\n    var sequelize = sql.sequelize;\r\n    var options = {};\r\n    if(where!=\"\"){\r\n        if(typeof where==\"object\"){\r\n            options.where = where;\r\n        }else{\r\n            options.where = sequelize.literal(where);\r\n        };\r\n    };\r\n    if(included_columns!=\"\" && excluded_columns==\"\"){\r\n        options.attributes = included_columns;\r\n    };\r\n    if(excluded_columns!=\"\"){\r\n        options.attributes = {exclude:excluded_columns};\r\n    };\r\n    if(order!=\"\"){\r\n        options.order = order;\r\n    };\r\n    if(offset!=\"\"){\r\n        options.offset = offset;\r\n    };\r\n    if(limit!=\"\"){\r\n        options.limit = limit;\r\n    };\r\n    var model = await util.get_model(sequelize, table);\r\n    var results = await model.findAll(options);\r\n    [[SQL_NODE_PARAMETERS]] = results;\r\n    sql.setTimeout(timeout);\r\n}catch(err){\r\n    sql.setTimeout(timeout);\r\n    throw err;\r\n};",
            "DataName": "SQL_SelectRecords",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        }
    ],
    "engine": [
        "engine.js"
    ],
    "icon": "SQL.png",
    "info": {
        "en": "Module for working with SQL databases (Postgres, MySQL, MariaDB, SQLite, MSSQL).",
        "ru": "Модуль для работы с SQL базами данных (Postgres, MySQL, MariaDB, SQLite, MSSQL)."
    },
    "is_autogenerated": true,
    "languages": [
        {
            "Name": "Node",
            "Version": "12.18.3"
        }
    ],
    "localize": {
		"Port": {"ru":"Порт"},
		"is empty": {"ru":"пуст"},
		"Username": {"ru":"Логин"},
		"Timeout": {"ru":"Таймаут"},
		"Password": {"ru":"Пароль"},
		"Host name": {"ru":"Имя хоста"},
		"Database name": {"ru":"Имя базы данных"},
		"Can be blank": {"ru":"Может быть пустым"},
		"Database port.": {"ru":"Порт базы данных."},
		"Timeout (seconds)": {"ru":"Таймаут (секунд)"},
		"Database dialect": {"ru":"Диалект базы данных"},
		"Database storage": {"ru":"Хранилище базы данных"},
		"Dialect of SQL database.": {"ru":"Диалект SQL базы данных."},
		"Username of the database.": {"ru":"Имя пользователя базы данных."},
		"Password of the database.": {"ru":"Пароль пользователя базы данных."},
		"Host (URL or IP) of the database.": {"ru":"Хост (URL или IP) базы данных."},
		"Setup access to SQL database.": {"ru":"Настроить доступ к SQL базе данных."},
		"Default port for PostgreSQL dialect": {"ru":"Порт по умолчанию для диалекта PostgreSQL"},
		"Default port for MicrosoftSQL dialect": {"ru":"Порт по умолчанию для диалекта MicrosoftSQL"},
		"Automatically detect port based on dialect": {"ru":"Автоматически определять порт по диалекту"},
		"Default port for MySQL and MariaDB dialects": {"ru":"Порт по умолчанию для диалектов MySQL и MariaDB"},
		"The path to the database storage. Only used by SQLite.": {"ru":"Путь к хранилищу базы данных. Используется только SQLite."},
		"This action should be called once before any other action that works with the SQL database.": {"ru":"Это действие нужно вызвать один раз перед любым другим действием, которое работает с SQL базой данных."},
        "If a resource is specified in the \"Database storage\" parameter, resource location will be used.": {"ru":"Если в параметре \"Хранилище базы данных\" указан ресурс, вместо содержимого ресурса будет браться его расположение."},
        "This action won't start connection, it only sets configuration. Connection will be established after first attempt to access the database. When action, which triggers connection will be finished, connection won't be closed immediately. It will be preserved for a time specified in this parameter. If another action will require access to database, connection will be reused.": {"ru":"Это действие не устанавливает соединение сразу. Соединение будет установлено только после первой попытки доступа к базе. Когда действие, запускающее соединение, будет завершено, соединение не будет закрыто. Оно будет храниться в течение времени, указанного в этом параметре. Если другое действие снова потребует доступа к базе, соединение будет повторно использовано."},
        "This action won't start connection, it only sets configuration. Connection will be established after first attempt to access the database. When action, which triggers connection will be finished, connection won't be closed immediately. It will be preserved for a time specified in \"Timeout\" parameter. If another action will require access to database, connection will be reused.": {"ru":"Это действие не устанавливает соединение сразу. Соединение будет установлено только после первой попытки доступа к базе. Когда действие, запускающее соединение, будет завершено, соединение не будет закрыто. Оно будет храниться в течение времени, указанного в параметре \"Таймаут\". Если другое действие снова потребует доступа к базе, соединение будет повторно использовано."},
		
		"Query": {"ru":"Запрос"},
		"Results": {"ru":"Результаты"},
		"Metadata": {"ru":"Метаданные"},
		"Query type": {"ru":"Тип запроса"},
		"Do not process query results": {"ru":"Не обрабатывать результаты запроса"},
		"Automatically detect query type": {"ru":"Автоматически определять тип запроса"},
		"Parameterize variables and resources.": {"ru":"Параметризировать переменные и ресурсы."},
		"The query to be executed against the database.": {"ru":"Запрос который нужно выполнить к базе данных."},
		"Execute an arbitrary query against an SQL database.": {"ru":"Выполнить произвольный запрос к SQL базе данных."},
		"Metadata will be received only for \"RAW\" query type.": {"ru":"Метаданные будут получены только при \"RAW\" типе запроса."},
		"The type of query you are executing. The query type affects how results are formatted.": {"ru":"Тип выполняемого запроса. Тип запроса влияет на форматирование результатов."},
		"Variable in which, after successful execution of the action, the metadata will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записаны метаданные."},
		"In order to execute this action correctly you need to run \"Setup connection\" action first.": {"ru":"Для правильной работы необходимо сначала выполнить действие \"Настроить соединение\"."},
		"Variable in which, after successful execution of the action, the results of the query will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записаны результаты выполнения запроса."},
		"If an error occurred while execute action, the thread will stop with fail message. If you want to continue thread, use \"Ignore errors\" action.":{"ru":"Если во время выполнения действия произойдет ошибка, поток остановится с сообщением об ошибке. Если вы хотите продолжить работу, используйте действие \"Игнорировать ошибки\"."},
		
		"Filter": {"ru":"Фильтр"},
		"Include all columns": {"ru":"Включить все поля"},
		"Don't skip records": {"ru":"Не пропускайте записи"},
		"Do not exclude columns": {"ru":"Не исключать поля"},
		"Do not filter records": {"ru":"Не фильтровать записи"},
		"Additional settings": {"ru":"Дополнительные настройки"},
		"List of included columns": {"ru":"Список включенных полей"},
		"List of excluded columns": {"ru":"Список исключенных полей"},
		"Number of records to skip.": {"ru":"Количество записей, которые нужно пропустить."},
		"Select single record from SQL database.": {"ru":"Получить одну запись из SQL базы данных."},
		"A set of conditions intended for selecting the records.": {"ru":"Набор условий, предназначенных для отбора записей."},
		"List of column names to be included in the final results.": {"ru":"Список имен полей, которые будут включены в итоговые результаты."},
		"List of column names to be excluded from the final results.": {"ru":"Список имен полей, которые будут исключены из итоговых результатов."},
		"Variable in which, after successful execution of the action, the record will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записана запись."},
		"As a list, you can use a string consisting of column names, separated by commas.": {"ru":"В качестве списка можно использовать строку, состоящую из имен полей, разделенных запятыми."},
		"If this parameter is specified, the value of the \"List of included columns\" parameter is ignored.": {"ru":"Если данный параметр указан, значение параметра \"Список включенных полей\" не учитывается."},
		"If the \"List of excluded columns\" parameter is specified, the value of this parameter is ignored.": {"ru":"Если указан параметр \"Список исключенных полей\", значение данного параметра не учитывается."},
		
		"Limit": {"ru":"Лимит"},
		"Do not limit the number of results": {"ru":"Не ограничивайте количество результатов"},
		"Select multiple records from SQL database.": {"ru":"Получить несколько записей из SQL базы данных."},
		"Limiting the number of records in the final result.": {"ru":"Ограничение количества записей в итоговом результате."},
		"Variable in which, after successful execution of the action, the list of records will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записан список записей."},
		
		"Close connection to SQL database.": {"ru":"Закрыть соединение с SQL базой данных."},
		"If connection is already closed or not open yet, this action will do nothing.": {"ru":" Если соединение уже закрыто или ещё не открыто, это действие ничего не сделает."},
        "Exact autoclose timeout is specified in \"Setup connection\" action.":{"ru":"Точный значение максимального времени ожидания можно задать в действии \"Настроить соединение\"."},
        "This action is optional because connection is closed automatically if it is not used for a long time.": {"ru":"Это действие не является обязательным, так как соединение закрывается автоматически если оно не использовалось длительное время."}
    },
    "major_version": 1,
    "minor_version": 0,
    "modules": [
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "sequelize",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "mysql2",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "mariadb",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "tedious",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "pg",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "pg-hstore",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "sqlite3-offline",
            "ModuleVersion": "*"
        }
    ],
    "name": "SQL"
}
