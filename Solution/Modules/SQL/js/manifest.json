{
    "actions": [
		{
            "code": [
                {
                    "file": "SQL_Setup_code.js",
                    "name": "SQL_Setup_code"
                }
            ],
            "description": {
                "en": "Setup connection",
                "ru": "Настроить соединение"
            },
            "interface": "SQL_Setup_interface.js",
            "is_element": false,
            "name": "SQL_Setup",
            "select": "SQL_Setup_select.js",
            "template": "{{dialect}} : {{host}} : {{storage}}"
        },
        {
            "code": [
                {
                    "file": "SQL_Query_code.js",
                    "name": "SQL_Query_code"
                }
            ],
            "description": {
                "en": "Execute query",
                "ru": "Выполнить запрос"
            },
            "interface": "SQL_Query_interface.js",
            "is_element": false,
            "name": "SQL_Query",
            "select": "SQL_Query_select.js",
            "template": "{{query}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "SQL_CountRecords_code.js",
                    "name": "SQL_CountRecords_code"
                }
            ],
            "description": {
                "en": "Count records",
                "ru": "Количество записей"
            },
            "interface": "SQL_CountRecords_interface.js",
            "is_element": false,
            "name": "SQL_CountRecords",
            "select": "SQL_CountRecords_select.js",
            "template": "{{table}} : {{where}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "SQL_SelectRecord_code.js",
                    "name": "SQL_SelectRecord_code"
                }
            ],
            "description": {
                "en": "Select single record",
                "ru": "Получить одну запись"
            },
            "interface": "SQL_SelectRecord_interface.js",
            "is_element": false,
            "name": "SQL_SelectRecord",
            "select": "SQL_SelectRecord_select.js",
            "template": "{{table}} : {{where}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "SQL_SelectRecords_code.js",
                    "name": "SQL_SelectRecords_code"
                }
            ],
            "description": {
                "en": "Select multiple records",
                "ru": "Получить несколько записей"
            },
            "interface": "SQL_SelectRecords_interface.js",
            "is_element": false,
            "name": "SQL_SelectRecords",
            "select": "SQL_SelectRecords_select.js",
            "template": "{{table}} : {{where}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "SQL_UpdateRecord_code.js",
                    "name": "SQL_UpdateRecord_code"
                }
            ],
            "description": {
                "en": "Update single record",
                "ru": "Обновить одну запись"
            },
            "interface": "SQL_UpdateRecord_interface.js",
            "is_element": false,
            "name": "SQL_UpdateRecord",
            "select": "SQL_UpdateRecord_select.js",
            "template": "{{values}} -> {{table}} : {{where}}"
        },
		{
            "code": [
                {
                    "file": "SQL_UpdateRecords_code.js",
                    "name": "SQL_UpdateRecords_code"
                }
            ],
            "description": {
                "en": "Update multiple records",
                "ru": "Обновить несколько записей"
            },
            "interface": "SQL_UpdateRecords_interface.js",
            "is_element": false,
            "name": "SQL_UpdateRecords",
            "select": "SQL_UpdateRecords_select.js",
            "template": "{{values}} -> {{table}} : {{where}}"
        },
        {
            "code": [
                {
                    "file": "SQL_DeleteRecord_code.js",
                    "name": "SQL_DeleteRecord_code"
                }
            ],
            "description": {
                "en": "Delete single record",
                "ru": "Удалить одну запись"
            },
            "interface": "SQL_DeleteRecord_interface.js",
            "is_element": false,
            "name": "SQL_DeleteRecord",
            "select": "SQL_DeleteRecord_select.js",
            "template": "{{table}} : {{where}}"
        },
        {
            "code": [
                {
                    "file": "SQL_DeleteRecords_code.js",
                    "name": "SQL_DeleteRecords_code"
                }
            ],
            "description": {
                "en": "Delete multiple records",
                "ru": "Удалить несколько записей"
            },
            "interface": "SQL_DeleteRecords_interface.js",
            "is_element": false,
            "name": "SQL_DeleteRecords",
            "select": "SQL_DeleteRecords_select.js",
            "template": "{{table}} : {{where}}"
        },
		{
            "code": [
                {
                    "file": "SQL_Insert_code.js",
                    "name": "SQL_Insert_code"
                }
            ],
            "description": {
                "en": "Insert records",
                "ru": "Вставить записи"
            },
            "interface": "SQL_Insert_interface.js",
            "is_element": false,
            "name": "SQL_Insert",
            "select": "SQL_Insert_select.js",
            "template": "{{data}} -> {{table}}"
        },
        {
            "code": [
                {
                    "file": "SQL_Close_code.js",
                    "name": "SQL_Close_code"
                }
            ],
            "description": {
                "en": "Close connection",
                "ru": "Закрыть соединение"
            },
            "interface": "SQL_Close_interface.js",
            "is_element": false,
            "name": "SQL_Close",
            "select": "SQL_Close_select.js",
            "template": ""
        }
    ],
    "api_version": 1,
    "autogenerated_functions": [
        "SQL_Setup",
        "SQL_Query",
		"SQL_CountRecords",
		"SQL_SelectRecord",
		"SQL_SelectRecords",
		"SQL_UpdateRecord",
		"SQL_UpdateRecords",
        "SQL_DeleteRecord",
        "SQL_DeleteRecords",
        "SQL_Insert",
        "SQL_Close"
    ],
    "browser": [
    ],
    "depends": [
    ],
    "description": "Working with SQL databases",
    "description_small": {
        "en": "SQL",
        "ru": "SQL"
    },
    "developer_email": "sasha9817@mail.ru",
    "developer_name": "GhostZ",
    "developer_site": "https://t.me/GhostZed",
    "embeddeddata": [
        {
            "Data": "const Sequelize = require('sequelize');\nconst SqlString = require('sequelize/lib/sql-string');\nvar self = this;\n\nthis.connect_sql = async function(id, config){\n    var dialect = config.dialect;\n\n    if(typeof sql_connections==\"undefined\"){\n        sql_connections = {};\n    };\n\n    if(typeof sql_connections[id]==\"undefined\"){\n        sql_connections[id] = {};\n    };\n\n    if(typeof sql_connections[id][dialect]==\"undefined\" || JSON.stringify(sql_connections[id][dialect].config)!=JSON.stringify(config)){\n        var options = {};\n        var keys = Object.keys(config);\n        for(var key of keys){\n            if(config[key]!==\"\" && key!=\"storage\"){\n                options[key] = config[key];\n            };\n        };\n        if(dialect===\"sqlite\"){\n            if(config.storage){\n                options.storage = config.storage;\n            };\n            options.dialectModule = require('sqlite3-offline').verbose();\n        };\n        options.define = {freezeTableName: true};\n        sql_connections[id][dialect] = {\n            id: id,\n            dialect: dialect,\n            config: config,\n            sequelize: new Sequelize(options),\n            timeout: 0,\n            close: function(id=this.id, dialect=this.dialect){\n                if(typeof sql_connections!=\"undefined\" && typeof sql_connections[id]!=\"undefined\" && typeof sql_connections[id][dialect]!=\"undefined\"){\n                    var sql = sql_connections[id][dialect];\n                    sql.clearTimeout();\n                    sql.sequelize.close();\n                    return sql.delete();\n                };\n            },\n            setTimeout: function(timeout){\n                this.clearTimeout();\n                this.timeout = setTimeout(this.close, timeout, this.id, this.dialect);\n            },\n            clearTimeout: function(){\n                if(!this.timeout[\"_destroyed\"]){\n                    clearTimeout(this.timeout);\n                };\n            },\n            delete: function(){delete sql_connections[this.id][this.dialect]}\n        };\n        var sql_obj = sql_connections[id][dialect];\n        try{\n            await sql_obj.sequelize.authenticate();\n            return sql_obj;\n        }catch(err){\n            sql_obj.delete();\n            throw err;\n        };\n    }else{\n        sql_connections[id][dialect].clearTimeout();\n        if(typeof sql_connections==\"undefined\" || typeof sql_connections[id]==\"undefined\" || typeof sql_connections[id][dialect]==\"undefined\"){\n            var sql_obj = await self.connect_sql(id, config);\n            return sql_obj;\n        }else{\n            return sql_connections[id][dialect];\n        };\n    };\n};\nthis.get_model = async function(sql, table){\n    var sequelize = sql.sequelize;\n    var models = sequelize.models;\n    if(Object.keys(models).indexOf(table) > -1){\n        return models[table];\n    }else{\n        var QueryInterface = sequelize.getQueryInterface();\n        var schema = await QueryInterface.describeTable(table);\n        sql.fields = Object.keys(schema);\n        var primary_key = false;\n        for(var key of sql.fields){\n            if(schema[key][\"primaryKey\"]){\n                primary_key = true;\n                break;\n            };\n        };\n        if(!primary_key){\n            schema[sql.fields[0]][\"primaryKey\"] = true;\n        };\n        var model = sequelize.define(table, schema, {timestamps: false});\n        await model.sync();\n        return model;\n    };\n};\nthis.format = function(sql, replacements, dialect){\n    return SqlString.format(sql, replacements, null, dialect);\n};\nthis.restore_dates = function(values){\n    values = [].concat(values);\n    return values.map(function(value){return (typeof value==\"object\" && value.isDate) ? new Date(value.date) : (Array.isArray(value) ? value.map(function(e){return (typeof e==\"object\" && e.isDate) ? new Date(e.date) : e}) : value)});\n};\nthis.restore_dates_in_object = function(obj){\n    var new_obj = {};\n    var keys = Object.keys(obj);\n    for(const key of keys){\n        var value = obj[key];\n        new_obj[key] = (typeof value==\"object\" && value.isDate) ? new Date(value.date) : (Array.isArray(value) ? value.map(function(e){return (typeof e==\"object\" && e.isDate) ? new Date(e.date) : e}) : value);\n    };\n    return new_obj;\n};\nthis.csv_generate = function(list, separator=\",\"){\n    var res = '';\n    var first = true;\n    list.forEach(function(item=\"\"){\n        var add = item;\n        if(typeof item==\"string\" && (item.indexOf(\";\") > -1 || item.indexOf(\":\") > -1 || item.indexOf(\",\") > -1 || item.indexOf(separator) > -1)){\n            add = \"\\\"\" + add.replace(/[\"]/gi, \"\\\"\\\"\") + \"\\\"\";\n        };\n        if(item instanceof Date){\n            add = \"\\\"\" + add.toString() + \"\\\"\";\n        };\n        if(!first){\n            res += separator;\n        }else{\n            first = false;\n        };\n        res += add;\n    });\n    return res;\n};\nthis.csv_parse = function(line){\n    var res = [];\n    var index = 0;\n    var len = line.length;\n    var InsideQuotes = false;\n    var CurrentElement = '';\n    \n    while(index<len){\n        var c = line[index];\n        var n = '';\n        var HasNext = (index + 1) < len;\n        if(HasNext){\n            n = line[index + 1];\n        };\n        index++;\n\n        if(c=='\\\"'){\n            if(InsideQuotes){\n                if(!HasNext || n!='\\\"'){\n                    InsideQuotes = false;\n                    continue;\n                }else{\n                    CurrentElement += \"\\\"\";\n                    index++;\n                    continue;\n                }\n            }else{\n                InsideQuotes = true;\n                continue;\n            }\n        };\n\n        if(c==':' || c==';' || c==','){\n            if(InsideQuotes){\n                CurrentElement += c;\n                continue;\n            }else{\n                res.push(self.convert(CurrentElement));\n                CurrentElement = '';\n                continue;\n            }\n        };\n        CurrentElement += c;\n    };\n    res.push(self.convert(CurrentElement));\n\n    return res;\n};\nthis.format_results = function(results, format){\n    if(format==\"Object list\" || format==\"2D list\"){\n        results.forEach(function(row, ir){Object.keys(row).forEach(function(key){results[ir][key] = (row[key] instanceof Date) ? ({isDate:true,date:row[key].toString()}) : row[key]})});\n    };\n    if(format==\"2D list\" || format==\"CSV list\" || format==\"CSV string\"){\n\t\tresults = results.map(function(row){return Object.values(row)});\n        if(format==\"CSV list\" || format==\"CSV string\"){\n            results = results.map(function(row){return self.csv_generate(row, \":\")});\n            if(format==\"CSV string\"){\n                results = results.join(\"\\n\");\n            };\n        };\n    };\n    return results;\n};\nthis.convert = function(data){\n    return (typeof data==\"string\" && data!==\"\") ? (isNaN(data) ? (data==\"true\" || data==\"false\" ? data==\"true\" : data) : Number(data)) : data;\n};\nthis.format_data = function(data, fields){\n    if(typeof data==\"string\"){\n        var reg = /\\r?\\n/;\n        data = data.split(reg);\n    };\n    if(typeof data==\"object\" && ((typeof data[0]==\"object\" && Array.isArray(data[0])) || typeof data[0]!=\"object\")){\n        data = data.map(function(row){return (typeof row!=\"object\") ? self.csv_parse(row) : row.map(function(cell){return self.convert(cell)})});\n        data = data.map(function(row){\n\t\t\tvar fields_cut = fields.slice(0, row.length);\n\t\t\treturn Object.assign(...fields_cut.map(function(field, i){return {[field]:row[i]}}));\n\t\t});\n    };\n    if(typeof data==\"object\" && (typeof data[0]==\"object\" && !Array.isArray(data[0]))){\n        data = data.map(function(row){return self.restore_dates_in_object(row)});\n    };\n    return data;\n};",
            "DataName": "UtilSQL",
            "DataType": 1,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilSQL\");\r\n\r\nvar [id, config, timeout, query, query_type, data_format] = [[SQL_NODE_PARAMETERS]];\r\nvar [query_sql, query_parameterize, query_replacements] = query;\r\n\r\nvar options = {type:query_type};\r\nif(query_parameterize){\r\n    options.replacements = util.restore_dates(query_replacements);\r\n};\r\n\r\nvar sql = await util.connect_sql(id, config);\r\ntry{\r\n    var sequelize = sql.sequelize;\r\n    var results = await sequelize.query(query_sql, options);\r\n    [[SQL_NODE_PARAMETERS]] = query_type==\"SELECT\" ? [util.format_results(results, data_format), data_format, query_type] : [results, data_format, query_type];\r\n    await sequelize.sync();\r\n    sql.setTimeout(timeout);\r\n}catch(err){\r\n    sql.setTimeout(timeout);\r\n    throw err;\r\n};",
            "DataName": "SQL_Query",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "var id = [[SQL_NODE_PARAMETERS]];\r\n\r\nif(typeof sql_connections!=\"undefined\" && typeof sql_connections[id]!=\"undefined\"){\r\n    var dialects = Object.keys(sql_connections[id]);\r\n    for(let dialect of dialects){\r\n        sql_connections[id][dialect].close();\r\n    };\r\n};",
            "DataName": "SQL_Close",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilSQL\");\r\n\r\nvar [id, config, timeout, table, where, included_columns, excluded_columns, order, offset, limit, data_format] = [[SQL_NODE_PARAMETERS]];\r\nvar [where, where_parameterize, where_replacements] = where;\r\n\r\nif(where_parameterize){\r\n    replacements = util.restore_dates(where_replacements);\r\n    where = util.format(where, replacements, config.dialect);\r\n};\r\n\r\nvar sql = await util.connect_sql(id, config);\r\ntry{\r\n    var sequelize = sql.sequelize;\r\n    var model = await util.get_model(sql, table);\r\n    var options = {};\r\n    if(where!==\"\"){\r\n        if(typeof where==\"object\"){\r\n            options.where = where;\r\n        }else{\r\n            options.where = sequelize.literal(where);\r\n        };\r\n    };\r\n    if(included_columns!==\"\" && excluded_columns==\"\"){\r\n        options.attributes = included_columns;\r\n    };\r\n    if(excluded_columns!==\"\"){\r\n        options.attributes = {exclude:excluded_columns};\r\n    };\r\n    if(order!==\"\"){\r\n        options.order = order;\r\n    };\r\n    if(offset!==\"\"){\r\n        options.offset = offset;\r\n    };\r\n    if(limit!==\"\"){\r\n        options.limit = limit;\r\n    };\r\n    var results = await model.findAll(options);\r\n    results = results.map(function(row){return row.get()});\r\n    [[SQL_NODE_PARAMETERS]] = [util.format_results(results, data_format), data_format];\r\n    sql.setTimeout(timeout);\r\n}catch(err){\r\n    sql.setTimeout(timeout);\r\n    throw err;\r\n};",
            "DataName": "SQL_SelectRecords",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilSQL\");\r\n\r\nvar [id, config, timeout, table, where, limit] = [[SQL_NODE_PARAMETERS]];\r\nvar [where, where_parameterize, where_replacements] = where;\r\n\r\nif(where_parameterize){\r\n    replacements = util.restore_dates(where_replacements);\r\n    where = util.format(where, replacements, config.dialect);\r\n};\r\n\r\nvar sql = await util.connect_sql(id, config);\r\ntry{\r\n    var sequelize = sql.sequelize;\r\n    var model = await util.get_model(sql, table);\r\n    var options = {};\r\n    if(where!==\"\"){\r\n        if(typeof where==\"object\"){\r\n            options.where = where;\r\n        }else{\r\n            options.where = sequelize.literal(where);\r\n        };\r\n    };\r\n    if(limit!==\"\"){\r\n        options.limit = limit;\r\n    };\r\n    var results = await model.destroy(options);\r\n    sql.setTimeout(timeout);\r\n}catch(err){\r\n    sql.setTimeout(timeout);\r\n    throw err;\r\n};",
            "DataName": "SQL_DeleteRecords",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilSQL\");\r\n\r\nvar [id, config, timeout, table, values, where, fields, limit] = [[SQL_NODE_PARAMETERS]];\r\nvar [where, where_parameterize, where_replacements] = where;\r\n\r\nif(where_parameterize){\r\n    replacements = util.restore_dates(where_replacements);\r\n    where = util.format(where, replacements, config.dialect);\r\n};\r\n\r\nvalues = util.restore_dates_in_object(values);\r\n\r\nvar sql = await util.connect_sql(id, config);\r\ntry{\r\n    var sequelize = sql.sequelize;\r\n    var model = await util.get_model(sql, table);\r\n    var options = {};\r\n    if(typeof where==\"object\"){\r\n        options.where = where;\r\n    }else{\r\n        options.where = sequelize.literal(where);\r\n    };\r\n    if(fields!==\"\"){\r\n        options.fields = fields;\r\n    };\r\n    if(limit!==\"\"){\r\n        options.limit = limit;\r\n    };\r\n    var results = await model.update(values, options);\r\n    sql.setTimeout(timeout);\r\n}catch(err){\r\n    sql.setTimeout(timeout);\r\n    throw err;\r\n};",
            "DataName": "SQL_UpdateRecords",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilSQL\");\r\n\r\nvar [id, config, timeout, table, where] = [[SQL_NODE_PARAMETERS]];\r\nvar [where, where_parameterize, where_replacements] = where;\r\n\r\nif(where_parameterize){\r\n    replacements = util.restore_dates(where_replacements);\r\n    where = util.format(where, replacements, config.dialect);\r\n};\r\n\r\nvar sql = await util.connect_sql(id, config);\r\ntry{\r\n    var sequelize = sql.sequelize;\r\n    var model = await util.get_model(sql, table);\r\n    var options = {};\r\n    if(where!==\"\"){\r\n        if(typeof where==\"object\"){\r\n            options.where = where;\r\n        }else{\r\n            options.where = sequelize.literal(where);\r\n        };\r\n    };\r\n    var results = await model.count(options);\r\n    [[SQL_NODE_PARAMETERS]] = results;\r\n    sql.setTimeout(timeout);\r\n}catch(err){\r\n    sql.setTimeout(timeout);\r\n    throw err;\r\n};",
            "DataName": "SQL_CountRecords",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilSQL\");\r\n\r\nvar [id, config, timeout, table, fields, data] = [[SQL_NODE_PARAMETERS]];\r\n\r\nvar sql = await util.connect_sql(id, config);\r\ntry{\r\n    var model = await util.get_model(sql, table);\r\n    var options = {};\r\n    if(fields!==\"\"){\r\n        options.fields = fields;\r\n        data = util.format_data(data, fields);\r\n    }else{\r\n        data = util.format_data(data, sql.fields);\r\n    };\r\n    var results = await model.bulkCreate(data, options);\r\n    sql.setTimeout(timeout);\r\n}catch(err){\r\n    sql.setTimeout(timeout);\r\n    throw err;\r\n};",
            "DataName": "SQL_Insert",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        }
    ],
    "engine": [
        "engine.js"
    ],
    "icon": "SQL.png",
    "info": {
        "en": "Module for working with SQL databases (Postgres, MySQL, MariaDB, SQLite, MSSQL).",
        "ru": "Модуль для работы с SQL базами данных (Postgres, MySQL, MariaDB, SQLite, MSSQL)."
    },
    "is_autogenerated": true,
    "languages": [
        {
            "Name": "Node",
            "Version": "12.18.3"
        }
    ],
    "localize": {
		"Port": {"ru":"Порт"},
		"is empty": {"ru":"пуст"},
		"Username": {"ru":"Логин"},
		"Timeout": {"ru":"Таймаут"},
		"Password": {"ru":"Пароль"},
		"Host name": {"ru":"Имя хоста"},
		"Database name": {"ru":"Имя базы данных"},
		"Can be blank": {"ru":"Может быть пустым"},
		"Database port.": {"ru":"Порт базы данных."},
		"Timeout (seconds)": {"ru":"Таймаут (секунд)"},
		"Database dialect": {"ru":"Диалект базы данных"},
		"Database storage": {"ru":"Хранилище базы данных"},
		"Dialect of SQL database.": {"ru":"Диалект SQL базы данных."},
		"Username of the database.": {"ru":"Имя пользователя базы данных."},
		"Password of the database.": {"ru":"Пароль пользователя базы данных."},
		"Host (URL or IP) of the database.": {"ru":"Хост (URL или IP) базы данных."},
		"Setup access to SQL database.": {"ru":"Настроить доступ к SQL базе данных."},
		"Default port for PostgreSQL dialect": {"ru":"Порт по умолчанию для диалекта PostgreSQL"},
		"Default port for MicrosoftSQL dialect": {"ru":"Порт по умолчанию для диалекта MicrosoftSQL"},
		"Automatically detect port based on dialect": {"ru":"Автоматически определять порт по диалекту"},
		"Default port for MySQL and MariaDB dialects": {"ru":"Порт по умолчанию для диалектов MySQL и MariaDB"},
		"The path to the database storage. Only used by SQLite.": {"ru":"Путь к хранилищу базы данных. Используется только SQLite."},
        "It will be preserved for a time specified in this parameter.": {"ru":"Оно будет храниться в течение времени, указанного в этом параметре."},
        "It will be preserved for a time specified in \"Timeout\" parameter.": {"ru":"Оно будет храниться в течение времени, указанного в параметре \"Таймаут\"."},
        "If another action will require access to database, connection will be reused.": {"ru":"Если другое действие снова потребует доступа к базе, соединение будет повторно использовано."},
		"This action should be called once before any other action that works with the SQL database.": {"ru":"Это действие нужно вызвать один раз перед любым другим действием, которое работает с SQL базой данных."},
        "If a resource is specified in the \"Database storage\" parameter, resource location will be used.": {"ru":"Если в параметре \"Хранилище базы данных\" указан ресурс, вместо содержимого ресурса будет браться его расположение."},
        "This action won't start connection, it only sets configuration. Connection will be established after first attempt to access the database. When action, which triggers connection will be finished, connection won't be closed immediately.": {"ru":"Это действие не устанавливает соединение сразу. Соединение будет установлено только после первой попытки доступа к базе. Когда действие, запускающее соединение, будет завершено, соединение не будет закрыто."},
		
		"Example:": {"ru":"Пример:"},
		"SQL query": {"ru":"SQL запрос"},
		"tutorial": {"ru":"руководстве"},
		"Data format": {"ru":"Формат данных"},
		"Can be blank": {"ru":"Может быть пустым"},
		"Before parameterization:": {"ru":"До параметризации:"},
		"after parameterization:": {"ru":"после параметризации:"},
		"Variable to save the result": {"ru":"Переменная, в которую сохранить результат"},
		"Select all records from \"users\" table": {"ru":"Получить все записи из таблицы \"users\""},
		"The query to be executed against the database.": {"ru":"Запрос который нужно выполнить к базе данных."},
		"Parameterize variables and resources in the query.": {"ru":"Параметризировать переменные и ресурсы в запросе."},
		"Execute an arbitrary query against an SQL database.": {"ru":"Выполнить произвольный запрос к SQL базе данных."},
		"Delete records with id equal to 10 from \"users\" table": {"ru":"Удалить записи с id равным 10 из таблицы \"users\""},
		"Lists can be processed using actions from the \"List\" module.": {"ru":"Списки можно обработать с помощью действий из модуля \"Список\"."},
		"Objects can be processed using actions from the \"JSON\" module.": {"ru":"Объекты можно обработать с помощью действий из модуля \"JSON\"."},
		"For different dialects, the result of parameterization may differ.": {"ru":"Для разных диалектов результат параметризации может отличатся."},
		"A query can have multiple lines, you can learn more about SQL in": {"ru":"Запрос может иметь несколько строк, подробнее о SQL вы можете узнать в"},
		"2D list - a list that consists of lists containing the field values.": {"ru":"2D list - это список, состоящий из списков, содержащих значения полей."},
		"Delete records in which \"age\" is an empty field from the table \"users\"": {"ru":"Удалить записи в который \"age\" пустое поле из таблицы \"users\""},
		"Insert new record into \"users\" table, where field values are obtained from variables": {"ru":"Вставить новую запись в таблицу \"users\", где значения полей получены из переменных"},
		"CSV lines can be parsed using the \"Parse Line\" action from the \"Tools\" module.": {"ru":"CSV строки можно распарсить с помощью действия \"Парсить строку\" из модуля \"Инструменты\"."},
		"In order to execute this action correctly you need to run \"Setup connection\" action first.": {"ru":"Для правильной работы необходимо сначала выполнить действие \"Настроить соединение\"."},
		"Insert new record into \"users\" table, the \"name\" field is \"John\", the \"age\" field is 25": {"ru":"Вставить новую запись в таблицу \"users\", поле \"name\" равно \"John\", поле \"age\" равно 25"},
		"The format in which the received data will be stored in a variable if a SELECT query is executed.": {"ru":"Формат, в котором полученные данные будут сохранены в переменной, если выполняется SELECT запрос."},
		"Data from variables and resources will be escaped according to their type and used SQL dialect": {"ru":"Данные из переменных и ресурсов будут экранированы в соответствии с их типом и используемым SQL диалектом"},
		"Variable in which, after successful execution of the action, the results of the query will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записаны результаты выполнения запроса."},
		"If a SELECT query is executed, the format of the saved data depends on the \"Data format\" setting.": {"ru":"Если выполняется SELECT запрос, то формат сохраняемых данных зависит от значения параметра \"Формат данных\"."},
		"Select all records from \"users\" table in which the \"name\" field is equal to the value from the [[NAME]] variable": {"ru":"Получить все записи из таблицы \"users\", в которых поле \"name\" равно значению из переменной [[NAME]]"},
		"CSV list - a list that consists of CSV lines and CSV line consists of field values separated with \":\" symbol.": {"ru":"CSV list - это список, состоящий из CSV строк, а CSV строка состоит из значений полей, разделенных символом \":\"."},
		"CSV string - this CSV lines separated by a line break, and consisting of field values separated with \":\" symbol.": {"ru":"CSV string - это CSV строки, разделенные переносом строки и состоящие из значений полей, разделенных символом \":\"."},
		"Object list - a list that consists of objects, in the object the key is the name of the field, and the value is the content of the field.": {"ru":"Object list - это список, состоящий из объектов, в объекте ключ - это имя поля, а значение - это содержимое поля."},
		"For example, a string will be wrapped in quotes, the list will be converted to a string containing all the elements of the list, escaped and separated by commas.": {"ru":"Например, строка будут обернута кавычками, список будет преобразован в строку, содержащую все элементы списка, экаранированные и разделенные запятыми."},
		"If an error occurred while execute action, the thread will stop with fail message. If you want to continue thread, use \"Ignore errors\" action.":{"ru":"Если во время выполнения действия произойдет ошибка, поток остановится с сообщением об ошибке. Если вы хотите продолжить работу, используйте действие \"Игнорировать ошибки\"."},
		"If the parameter \"Parameterize variables and resources\" is activated, then data from variables and resources will be escaped according to their type and used SQL dialect.": {"ru":"Если активирован параметр \"Параметризировать переменные и ресурсы\", то данные из переменных и ресурсов будут экранированы в соответствии с их типом и используемым SQL диалектом."},
		
		"Filter": {"ru":"Фильтр"},
		"id equals 10": {"ru":"id равно 10"},
		"Include all columns": {"ru":"Включить все поля"},
		"radius from 30 to 90": {"ru":"radius от 30 до 90"},
		"amount field is empty": {"ru":"Поле amount пустое"},
		"Don't skip records": {"ru":"Не пропускайте записи"},
		"Do not exclude columns": {"ru":"Не исключать поля"},
		"Do not filter records": {"ru":"Не фильтровать записи"},
		"Additional settings": {"ru":"Дополнительные настройки"},
		"List of included columns": {"ru":"Список включенных полей"},
		"List of excluded columns": {"ru":"Список исключенных полей"},
		"Number of records to skip.": {"ru":"Количество записей, которые нужно пропустить."},
		"Select single record from SQL database.": {"ru":"Получить одну запись из SQL базы данных."},
		"List - a list consists the field values.": {"ru":"List - это список, состоящий из значений полей."},
		"id is equal to the value from the variable [[ID]]": {"ru":"id равно значению из переменной [[ID]]"},
		"id is equal to a value from the list 4, 12, 58, 67": {"ru":"id равно значению из списка 4, 12, 58, 67"},
		"name is equal to john and balance is more than one hundred": {"ru":"name равно john и balance больше ста"},
		"title is equal to the value from the resource {{title}}": {"ru":"title равно значению из ресурса {{title}}"},
		"Parameterize variables and resources in the filter.": {"ru":"Параметризировать переменные и ресурсы в фильтре."},
		"A set of conditions intended for selecting the records.": {"ru":"Набор условий, предназначенных для отбора записей."},
		"List of column names to be included in the final results.": {"ru":"Список имен полей, которые будут включены в итоговые результаты."},
		"List of column names to be excluded from the final results.": {"ru":"Список имен полей, которые будут исключены из итоговых результатов."},
		"id is equal to the value from the list in the [[ID_LIST]] variable": {"ru":"id равно значению из списка находящемуся в переменной [[ID_LIST]]"},
		"The format in which the received data will be stored in a variable.": {"ru":"Формат, в котором полученные данные будут сохранены в переменной."},
		"CSV - a string consisting of field values separated by \":\".": {"ru":"CSV - это строка, состоящая из значений полей, разделенных символом \":\"."},
		"The format of the saved data depends on the \"Data format\" setting.": {"ru":"Формат сохраняемых данных зависит от значения параметра \"Формат данных\"."},
		"As a list, you can use a string consisting of column names, separated by commas.": {"ru":"В качестве списка можно использовать строку, состоящую из имен полей, разделенных запятыми."},
		"Object - an object, in which the key - a field name and value - the content of the field.": {"ru":"Object - это объект, в котором ключ - это имя поля, а значение - это содержимое поля."},
		"Variable in which, after successful execution of the action, the received record will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записана полученная запись."},
		"If this parameter is specified, the value of the \"List of included columns\" parameter is ignored.": {"ru":"Если данный параметр указан, значение параметра \"Список включенных полей\" не учитывается."},
		"If the \"List of excluded columns\" parameter is specified, the value of this parameter is ignored.": {"ru":"Если указан параметр \"Список исключенных полей\", значение данного параметра не учитывается."},
		
		"Limit": {"ru":"Лимит"},
		"Do not limit the number of results": {"ru":"Не ограничивайте количество результатов"},
		"Select multiple records from SQL database.": {"ru":"Получить несколько записей из SQL базы данных."},
		"Limiting the number of records in the final result.": {"ru":"Ограничение количества записей в итоговом результате."},
		"Variable in which, after successful execution of the action, the received records will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записаны полученные записи."},
		
		"Values": {"ru":"Значения"},
		"List of fields": {"ru":"Список полей"},
		"Update single record from SQL database.": {"ru":"Обновить одну запись из SQL базы данных."},
		"Field names and values separated by \"=\", each field on a new line.": {"ru":"Названия полей и их значения разделенные символом \"=\", каждое поле с новой строки."},
		"This action replaces the field values of an existing record with the specified ones.": {"ru":"Данное действие заменяет значения полей, уже существующей записи, на указанные."},
		"List of field names that can be updated. Can be used as a constraint to avoid accidentally updating unnecessary fields.": {"ru":"Список имен полей, которые можно обновить. Может использоваться как ограничение, чтобы избежать случайного обновления ненужных полей."},
		"For example, the string <code>\"123\"</code> will be automatically converted to the number <code>123</code>, and the string <code>\"true\"</code> will be converted to the boolean type <code>true</code>.": {"ru":"Например, строка <code>\"123\"</code> будет автоматически преобразована в число <code>123</code>, а строка <code>\"true\"</code> будет преобразована в булевый тип <code>true</code>."},
		
		"Update all fields": {"ru":"Обновить все поля"},
		"Update all records matching filters": {"ru":"Обновлять все записи, подходящие под фильтры"},
		"Limiting the number of updated records.": {"ru":"Ограничение количества обновляемых записей."},
		"Update multiple records from SQL database.": {"ru":"Обновить несколько записей из SQL базы данных."},
		"This action replaces the values of the fields of existing records with the specified ones.": {"ru":"Данное действие заменяет значения полей, уже существующих записей, на указанные."},
		
		"Delete single record from SQL database.": {"ru":"Удалить одну запись из SQL базы данных."},
		
		"Delete all records matching filters": {"ru":"Удалить все записи, подходящие под фильтры"},
		"Limiting the number of records to be deleted.": {"ru":"Ограничение количества удаляемых записей."},
		"Delete multiple records from SQL database.": {"ru":"Удалить несколько записей из SQL базы данных."},
		
		"Number of records": {"ru":"Количество записей"},
		"Get the number of records from SQL database.": {"ru":"Получить количество записей из SQL базы данных."},
		"Variable in which, after successful execution of the action, the number of records will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записано количество записей."},
		
		"Records": {"ru":"Записи"},
		"Can be blank": {"ru":"Может быть пустым"},
		"Insert records into SQL database.": {"ru":"Вставить записи в SQL базу данных."},
		"The data to be inserted into the database.": {"ru":"Данные, которые нужно вставить в базу."},
		"Insert all fields, the order of the fields matches the database": {"ru":"Вставлять все поля, порядок полей совпадает с базой"},
		"The field value can be string, number, boolean or date.": {"ru":"Значением поля может быть строка, число, булевый тип или дата."},
		"You can write strings, numbers, booleans and dates to field.": {"ru":"В поле можно записывать строки, числа, булевый тип и дату."},
		"Data can be generated manually by using \"List\" module or \"Template\" action.": {"ru":"Данные можно сгенерировать вручную с помощью модуля \"Список\" или действия \"Шаблон\"."},
		"Data in a suitable format can be obtained from the actions: \"Select single record\", \"Select multiple records\".": {"ru":"Данные в подходящем формате можно получить из действий: \"Получить одну запись\", \"Получить несколько записей\"."},
		"List of field names to be inserted. Can be used as a constraint to avoid accidentally inserting unnecessary fields.": {"ru":"Список имен полей, которые будут вставлены. Может использоваться как ограничение, чтобы избежать случайноё вставки ненужных полей."},
		"Also, this parameter must be specified if the data format is not \"Object list\" and the order of the fields does not match the table.": {"ru":"Также, данный параметр нужно указывать, если формат данных не \"Object list\" и порядок полей не совподает с таблицей."},
		"This action accepts data in the formats: \"CSV\", \"CSV list\", \"CSV string\", \"List\", \"2D list\", \"Object\", \"Object list\".": {"ru":"Данное действие принимает данные в форматах: \"CSV\", \"CSV list\", \"CSV string\", \"List\", \"2D list\", \"Object\", \"Object list\"."},
		"If the data format is not \"Object list\" and the order of the fields in the data does not correspond to the database, then the \"List of fields\" parameter must be specified.": {"ru":"Если формат данных не \"Object list\" и в данных порядок полей не соответствует базе, то нужно указывать параметр \"Список полей\"."},
		"Numbers and booleans can be specified as a string and they will be automatically converted to the correct type, and dates are perceived only as a javascript date object.": {"ru":"Числа и булевый тип можно указывать в виде строки и они будут автоматически конвертированы в нужный тип, а даты воспринимаются только в виде javascript объекта даты."},
		"For example, the string <code>\"123\"</code> will be automatically converted to the number <code>123</code>, and the string <code>\"true\"</code> will be converted to the boolean type <code>true</code>.": {"ru":"Например, строка <code>\"123\"</code> будет автоматически преобразована в число <code>123</code>, а строка <code>\"true\"</code> будет преобразована в булевый тип <code>true</code>."},
		
		"Close connection to SQL database.": {"ru":"Закрыть соединение с SQL базой данных."},
		"If connection is already closed or not open yet, this action will do nothing.": {"ru":" Если соединение уже закрыто или ещё не открыто, это действие ничего не сделает."},
        "Exact autoclose timeout is specified in \"Setup connection\" action.":{"ru":"Точный значение максимального времени ожидания можно задать в действии \"Настроить соединение\"."},
        "This action is optional because connection is closed automatically if it is not used for a long time.": {"ru":"Это действие не является обязательным, так как соединение закрывается автоматически если оно не использовалось длительное время."}
    },
    "major_version": 1,
    "minor_version": 0,
    "modules": [
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "sequelize",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "mysql2",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "mariadb",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "tedious",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "pg",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "pg-hstore",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "sqlite3-offline",
            "ModuleVersion": "*"
        }
    ],
    "name": "SQL"
}
