{
    "actions": [
		{
            "code": [
                {
                    "file": "Excel_CreateFile_code.js",
                    "name": "Excel_CreateFile_code"
                }
            ],
            "description": {
                "en": "Create file",
                "ru": "Создать файл"
            },
            "interface": "Excel_CreateFile_interface.js",
            "is_element": false,
            "name": "Excel_CreateFile",
            "select": "Excel_CreateFile_select.js",
            "template": "{{FilePath}}"
        },
		{
            "code": [
                {
                    "file": "Excel_GetSheetsList_code.js",
                    "name": "Excel_GetSheetsList_code"
                }
            ],
            "description": {
                "en": "Get sheets list",
                "ru": "Получить список листов"
            },
            "interface": "Excel_GetSheetsList_interface.js",
            "is_element": false,
            "name": "Excel_GetSheetsList",
            "select": "Excel_GetSheetsList_select.js",
            "template": "{{FilePath}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "Excel_AddSheet_code.js",
                    "name": "Excel_AddSheet_code"
                }
            ],
            "description": {
                "en": "Add sheet",
                "ru": "Добавить лист"
            },
            "interface": "Excel_AddSheet_interface.js",
            "is_element": false,
            "name": "Excel_AddSheet",
            "select": "Excel_AddSheet_select.js",
            "template": "{{SheetName}} -> {{FilePath}}"
        },
        {
            "code": [
                {
                    "file": "Excel_RenameSheet_code.js",
                    "name": "Excel_RenameSheet_code"
                }
            ],
            "description": {
                "en": "Rename sheet",
                "ru": "Переименовать лист"
            },
            "interface": "Excel_RenameSheet_interface.js",
            "is_element": false,
            "name": "Excel_RenameSheet",
            "select": "Excel_RenameSheet_select.js",
            "template": "{{SheetIndexOrName}} -> {{NewSheetName}}"
        },
		{
            "code": [
                {
                    "file": "Excel_MoveSheet_code.js",
                    "name": "Excel_MoveSheet_code"
                }
            ],
            "description": {
                "en": "Move sheet",
                "ru": "Переместить лист"
            },
            "interface": "Excel_MoveSheet_interface.js",
            "is_element": false,
            "name": "Excel_MoveSheet",
            "select": "Excel_MoveSheet_select.js",
            "template": "{{SheetIndexOrName}} -> {{NewSheetIndex}}"
        },
		{
            "code": [
                {
                    "file": "Excel_DeleteSheet_code.js",
                    "name": "Excel_DeleteSheet_code"
                }
            ],
            "description": {
                "en": "Delete sheet",
                "ru": "Удалить лист"
            },
            "interface": "Excel_DeleteSheet_interface.js",
            "is_element": false,
            "name": "Excel_DeleteSheet",
            "select": "Excel_DeleteSheet_select.js",
            "template": "{{SheetIndexOrName}}"
        },
        {
            "code": [
                {
                    "file": "Excel_ReadCell_code.js",
                    "name": "Excel_ReadCell_code"
                }
            ],
            "description": {
                "en": "Read cell",
                "ru": "Читать ячейку"
            },
            "interface": "Excel_ReadCell_interface.js",
            "is_element": false,
            "name": "Excel_ReadCell",
            "select": "Excel_ReadCell_select.js",
            "template": "{{CellAddress}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "Excel_WriteToCell_code.js",
                    "name": "Excel_WriteToCell_code"
                }
            ],
            "description": {
                "en": "Write to cell",
                "ru": "Запись в ячейку"
            },
            "interface": "Excel_WriteToCell_interface.js",
            "is_element": false,
            "name": "Excel_WriteToCell",
            "select": "Excel_WriteToCell_select.js",
            "template": "{{Data}} -> {{CellAddress}}"
        },
        {
            "code": [
                {
                    "file": "Excel_ReadSheet_code.js",
                    "name": "Excel_ReadSheet_code"
                }
            ],
            "description": {
                "en": "Read sheet",
                "ru": "Читать лист"
            },
            "interface": "Excel_ReadSheet_interface.js",
            "is_element": false,
            "name": "Excel_ReadSheet",
            "select": "Excel_ReadSheet_select.js",
            "template": "{{SheetIndexOrName}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "Excel_WriteToSheet_code.js",
                    "name": "Excel_WriteToSheet_code"
                }
            ],
            "description": {
                "en": "Write to sheet",
                "ru": "Запись на лист"
            },
            "interface": "Excel_WriteToSheet_interface.js",
            "is_element": false,
            "name": "Excel_WriteToSheet",
            "select": "Excel_WriteToSheet_select.js",
            "template": "{{Data}} -> {{SheetIndexOrName}}"
        },
		{
            "code": [
                {
                    "file": "Excel_CountRows_code.js",
                    "name": "Excel_CountRows_code"
                }
            ],
            "description": {
                "en": "Count rows",
                "ru": "Количество строк"
            },
            "interface": "Excel_CountRows_interface.js",
            "is_element": false,
            "name": "Excel_CountRows",
            "select": "Excel_CountRows_select.js",
            "template": "{{SheetIndexOrName}} -> {{Save}}"
        },
        {
            "code": [
                {
                    "file": "Excel_ReadRows_code.js",
                    "name": "Excel_ReadRows_code"
                }
            ],
            "description": {
                "en": "Read rows",
                "ru": "Читать строки"
            },
            "interface": "Excel_ReadRows_interface.js",
            "is_element": false,
            "name": "Excel_ReadRows",
            "select": "Excel_ReadRows_select.js",
            "template": "{{FromRow}}:{{ToRow}} -> {{Save}}"
        },
        {
            "code": [
                {
                    "file": "Excel_InsertRows_code.js",
                    "name": "Excel_InsertRows_code"
                }
            ],
            "description": {
                "en": "Insert rows",
                "ru": "Вставить строки"
            },
            "interface": "Excel_InsertRows_interface.js",
            "is_element": false,
            "name": "Excel_InsertRows",
            "select": "Excel_InsertRows_select.js",
            "template": "{{Data}} -> {{FromRow}}"
        },
		{
            "code": [
                {
                    "file": "Excel_DeleteRows_code.js",
                    "name": "Excel_DeleteRows_code"
                }
            ],
            "description": {
                "en": "Delete rows",
                "ru": "Удалить строки"
            },
            "interface": "Excel_DeleteRows_interface.js",
            "is_element": false,
            "name": "Excel_DeleteRows",
            "select": "Excel_DeleteRows_select.js",
            "template": "{{FromRow}} - {{Count}}"
        },
        {
            "code": [
                {
                    "file": "Excel_ReadCellsRange_code.js",
                    "name": "Excel_ReadCellsRange_code"
                }
            ],
            "description": {
                "en": "Read cells range",
                "ru": "Читать область ячеек"
            },
            "interface": "Excel_ReadCellsRange_interface.js",
            "is_element": false,
            "name": "Excel_ReadCellsRange",
            "select": "Excel_ReadCellsRange_select.js",
            "template": "{{FromCell}}:{{ToCell}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "Excel_WriteToCellsRange_code.js",
                    "name": "Excel_WriteToCellsRange_code"
                }
            ],
            "description": {
                "en": "Write to cells range",
                "ru": "Запись в область ячеек"
            },
            "interface": "Excel_WriteToCellsRange_interface.js",
            "is_element": false,
            "name": "Excel_WriteToCellsRange",
            "select": "Excel_WriteToCellsRange_select.js",
            "template": "{{Data}} -> {{FromCell}}:{{ToCell}}"
        },
        {
            "code": [
                {
                    "file": "Excel_ImportToResources_code.js",
                    "name": "Excel_ImportToResources_code"
                }
            ],
            "description": {
                "en": "Import from file to resources",
                "ru": "Импорт из файла в ресурсы"
            },
            "interface": "Excel_ImportToResources_interface.js",
            "is_element": false,
            "name": "Excel_ImportToResources",
            "select": "Excel_ImportToResources_select.js",
            "template": "{{FilePath}}"
        },
		{
            "code": [
                {
                    "file": "Excel_ExportFromResources_code.js",
                    "name": "Excel_ExportFromResources_code"
                }
            ],
            "description": {
                "en": "Export from resources to file",
                "ru": "Экспорт из ресурсов в файл"
            },
            "interface": "Excel_ExportFromResources_interface.js",
            "is_element": false,
            "name": "Excel_ExportFromResources",
            "select": "Excel_ExportFromResources_select.js",
            "template": "{{ResourceList}} -> {{FilePath}}"
        },
		{
            "code": [
                {
                    "file": "Excel_ClearSheet_code.js",
                    "name": "Excel_ClearSheet_code"
                }
            ],
            "description": {
                "en": "Clear sheet",
                "ru": "Очистить лист"
            },
            "interface": "Excel_ClearSheet_interface.js",
            "is_element": false,
            "name": "Excel_ClearSheet",
            "select": "Excel_ClearSheet_select.js",
            "template": "{{SheetIndexOrName}}"
        },
		{
            "code": [
                {
                    "file": "Excel_ClearCell_code.js",
                    "name": "Excel_ClearCell_code"
                }
            ],
            "description": {
                "en": "Clear cell",
                "ru": "Очистить ячейку"
            },
            "interface": "Excel_ClearCell_interface.js",
            "is_element": false,
            "name": "Excel_ClearCell",
            "select": "Excel_ClearCell_select.js",
            "template": "{{CellAddress}}"
        },
		{
            "code": [
                {
                    "file": "Excel_ClearCellsRange_code.js",
                    "name": "Excel_ClearCellsRange_code"
                }
            ],
            "description": {
                "en": "Clear cells range",
                "ru": "Очистить область ячеек"
            },
            "interface": "Excel_ClearCellsRange_interface.js",
            "is_element": false,
            "name": "Excel_ClearCellsRange",
            "select": "Excel_ClearCellsRange_select.js",
            "template": "{{FromCell}}:{{ToCell}}"
        },
        {
            "code": [
                {
                    "file": "Excel_ConvertToJSON_code.js",
                    "name": "Excel_ConvertToJSON_code"
                }
            ],
            "description": {
                "en": "Convert to JSON",
                "ru": "Преобразовать в JSON"
            },
            "interface": "Excel_ConvertToJSON_interface.js",
            "is_element": false,
            "name": "Excel_ConvertToJSON",
            "select": "Excel_ConvertToJSON_select.js",
            "template": "{{FilePath}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "Excel_ConvertFromJSON_code.js",
                    "name": "Excel_ConvertFromJSON_code"
                }
            ],
            "description": {
                "en": "Convert from JSON",
                "ru": "Преобразовать из JSON"
            },
            "interface": "Excel_ConvertFromJSON_interface.js",
            "is_element": false,
            "name": "Excel_ConvertFromJSON",
            "select": "Excel_ConvertFromJSON_select.js",
            "template": "{{Data}} -> {{FilePath}}"
        },
		{
            "code": [
                {
                    "file": "Excel_FindCell_code.js",
                    "name": "Excel_FindCell_code"
                }
            ],
            "description": {
                "en": "Find single cell",
                "ru": "Найти одну ячейку"
            },
            "interface": "Excel_FindCell_interface.js",
            "is_element": false,
            "name": "Excel_FindCell",
            "select": "Excel_FindCell_select.js",
            "template": "{{FilePath}} -> {{Column}}*{{Row}}"
        },
        {
            "code": [
                {
                    "file": "Excel_FindCells_code.js",
                    "name": "Excel_FindCells_code"
                }
            ],
            "description": {
                "en": "Find all cells",
                "ru": "Найти все ячейки"
            },
            "interface": "Excel_FindCells_interface.js",
            "is_element": false,
            "name": "Excel_FindCells",
            "select": "Excel_FindCells_select.js",
            "template": "{{FilePath}} -> {{Save}}"
        },
        {
            "code": [
                {
                    "file": "Excel_GetFormulaFromCell_code.js",
                    "name": "Excel_GetFormulaFromCell_code"
                }
            ],
            "description": {
                "en": "Get formula from cell",
                "ru": "Получить формулу из ячейки"
            },
            "interface": "Excel_GetFormulaFromCell_interface.js",
            "is_element": false,
            "name": "Excel_GetFormulaFromCell",
            "select": "Excel_GetFormulaFromCell_select.js",
            "template": "{{CellAddress}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "Excel_SetFormulaToCell_code.js",
                    "name": "Excel_SetFormulaToCell_code"
                }
            ],
            "description": {
                "en": "Set formula to cell",
                "ru": "Установить формулу в ячейку"
            },
            "interface": "Excel_SetFormulaToCell_interface.js",
            "is_element": false,
            "name": "Excel_SetFormulaToCell",
            "select": "Excel_SetFormulaToCell_select.js",
            "template": "{{Formula}} -> {{CellAddress}}"
        },
        {
            "code": [
                {
                    "file": "Excel_GetCellStyle_code.js",
                    "name": "Excel_GetCellStyle_code"
                }
            ],
            "description": {
                "en": "Get cell style",
                "ru": "Получить стиль ячейки"
            },
            "interface": "Excel_GetCellStyle_interface.js",
            "is_element": false,
            "name": "Excel_GetCellStyle",
            "select": "Excel_GetCellStyle_select.js",
            "template": "{{CellAddress}} -> {{Save}}"
        },
        {
            "code": [
                {
                    "file": "Excel_GetCellStyles_code.js",
                    "name": "Excel_GetCellStyles_code"
                }
            ],
            "description": {
                "en": "Get cell styles",
                "ru": "Получить стили ячейки"
            },
            "interface": "Excel_GetCellStyles_interface.js",
            "is_element": false,
            "name": "Excel_GetCellStyles",
            "select": "Excel_GetCellStyles_select.js",
            "template": "{{CellAddress}} -> {{Save}}"
        },
        {
            "code": [
                {
                    "file": "Excel_SetStyleToCell_code.js",
                    "name": "Excel_SetStyleToCell_code"
                }
            ],
            "description": {
                "en": "Set style to cell",
                "ru": "Установить стиль для ячейки"
            },
            "interface": "Excel_SetStyleToCell_interface.js",
            "is_element": false,
            "name": "Excel_SetStyleToCell",
            "select": "Excel_SetStyleToCell_select.js",
            "template": "{{StyleName}}:{{StyleValue}} -> {{CellAddress}}"
        },
        {
            "code": [
                {
                    "file": "Excel_SetStylesToCell_code.js",
                    "name": "Excel_SetStylesToCell_code"
                }
            ],
            "description": {
                "en": "Set styles to cell",
                "ru": "Установить стили для ячейки"
            },
            "interface": "Excel_SetStylesToCell_interface.js",
            "is_element": false,
            "name": "Excel_SetStylesToCell",
            "select": "Excel_SetStylesToCell_select.js",
            "template": "{{Styles}} -> {{CellAddress}}"
        },
        {
            "code": [
                {
                    "file": "Excel_SetStyleToCellsRange_code.js",
                    "name": "Excel_SetStyleToCellsRange_code"
                }
            ],
            "description": {
                "en": "Set style to cells range",
                "ru": "Установить стиль для области ячеек"
            },
            "interface": "Excel_SetStyleToCellsRange_interface.js",
            "is_element": false,
            "name": "Excel_SetStyleToCellsRange",
            "select": "Excel_SetStyleToCellsRange_select.js",
            "template": "{{StyleName}}:{{StyleValue}} -> {{FromCell}}:{{ToCell}}"
        },
		{
            "code": [
                {
                    "file": "Excel_SetStylesToCellsRange_code.js",
                    "name": "Excel_SetStylesToCellsRange_code"
                }
            ],
            "description": {
                "en": "Set styles to cells range",
                "ru": "Установить стили для области ячеек"
            },
            "interface": "Excel_SetStylesToCellsRange_interface.js",
            "is_element": false,
            "name": "Excel_SetStylesToCellsRange",
            "select": "Excel_SetStylesToCellsRange_select.js",
            "template": "{{Styles}} -> {{FromCell}}:{{ToCell}}"
        }
    ],
    "api_version": 1,
    "autogenerated_functions": [
        "Excel_CreateFile",
        "Excel_GetSheetsList",
        "Excel_AddSheet",
        "Excel_RenameSheet",
		"Excel_MoveSheet",
        "Excel_DeleteSheet",
        "Excel_ReadCell",
        "Excel_WriteToCell",
        "Excel_ReadSheet",
        "Excel_WriteToSheet",
        "Excel_ReadRows",
        "Excel_InsertRows",
        "Excel_DeleteRows",
        "Excel_ReadCellsRange",
        "Excel_WriteToCellsRange",
        "Excel_ImportToResources",
        "Excel_ExportFromResources",
        "Excel_ClearSheet",
        "Excel_ClearCell",
        "Excel_ClearCellsRange",
        "Excel_ConvertToJSON",
        "Excel_ConvertFromJSON",
        "Excel_FindCell",
        "Excel_FindCells",
        "Excel_GetFormulaFromCell",
        "Excel_SetFormulaToCell",
        "Excel_GetCellStyle",
        "Excel_GetCellStyles",
        "Excel_SetStyleToCell",
        "Excel_SetStylesToCell",
        "Excel_SetStyleToCellsRange",
        "Excel_SetStylesToCellsRange"
    ],
    "browser": [
    ],
    "depends": [
    ],
    "description": "Working with excel files",
    "description_small": {
        "en": "Excel",
        "ru": "Excel"
    },
    "developer_email": "sasha9817@mail.ru",
    "developer_name": "GhostZ",
    "developer_site": "https://t.me/GhostZed",
    "embeddeddata": [
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar sheet_index = [[XLSX_NODE_PARAMETERS]][2];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        var file = exist ? xlsx.fromFileAsync(file_path) : xlsx.fromBlankAsync();\r\n        file.then(function(workbook){\r\n            try{\r\n                sheet_index===\"\" ? (exist ? workbook.addSheet(sheet_name) : workbook.sheet(0).name(sheet_name)) : workbook.addSheet(sheet_name, sheet_index);\r\n            }catch(err){\r\n                reject(err);\r\n            };\r\n            \r\n            var toFile = workbook.toFileAsync(file_path);\r\n            toFile.then(function(){\r\n                return resolve();\r\n            });\r\n            toFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        });\r\n        file.catch(function(err){\r\n            return reject(err);\r\n        });\r\n    });\r\n}));",
            "DataName": "ExcelAddSheet",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar new_sheet_name = [[XLSX_NODE_PARAMETERS]][2];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        var file = exist ? xlsx.fromFileAsync(file_path) : xlsx.fromBlankAsync();\r\n        file.then(function(workbook){\r\n            try{\r\n                var sheet = workbook.sheet(sheet_index_or_name);\r\n                sheet ? sheet.name(new_sheet_name) : workbook.addSheet(new_sheet_name);\r\n            }catch(err){\r\n                reject(err);\r\n            };\r\n            \r\n            var toFile = workbook.toFileAsync(file_path);\r\n            toFile.then(function(){\r\n                return resolve();\r\n            });\r\n            toFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        });\r\n        file.catch(function(err){\r\n            return reject(err);\r\n        });\r\n    });\r\n}));",
            "DataName": "ExcelRenameSheet",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar new_sheet_index = [[XLSX_NODE_PARAMETERS]][2];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        new_sheet_index===\"\" ? workbook.moveSheet(sheet_index_or_name) : workbook.moveSheet(sheet_index_or_name, new_sheet_index);\r\n                    }else{\r\n                        reject('Sheet ' + JSON.stringify(sheet_index_or_name) + ' does not exist');\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                var toFile = workbook.toFileAsync(file_path);\r\n                toFile.then(function(){\r\n                    return resolve();\r\n                });\r\n                toFile.catch(function(err){\r\n                    return reject(err);\r\n                });\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            reject('The file \"' + file_path + '\" does not exist');\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelMoveSheet",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    sheet ? sheet.delete() : resolve();\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                var toFile = workbook.toFileAsync(file_path);\r\n                toFile.then(function(){\r\n                    return resolve();\r\n                });\r\n                toFile.catch(function(err){\r\n                    return reject(err);\r\n                });\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            resolve();\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelDeleteSheet",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst RichText = require('xlsx-Populate').RichText;\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar cell_address = [[XLSX_NODE_PARAMETERS]][2];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        var value = sheet.cell(cell_address).value();\r\n                        [[XLSX_NODE_PARAMETERS]] = (typeof value==\"undefined\") ? \"\" : (value instanceof RichText ? value.text() : (typeof value[\"_error\"]===\"undefined\" ? value : \"\"));\r\n                    }else{\r\n                        reject('Sheet ' + JSON.stringify(sheet_index_or_name) + ' does not exist');\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                return resolve();\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            reject('The file \"' + file_path + '\" does not exist');\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelReadCell",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar cell_address = [[XLSX_NODE_PARAMETERS]][2];\r\nvar data = [[XLSX_NODE_PARAMETERS]][3];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    data = util.convert(data);\r\n    fs.exists(file_path, function(exist){\r\n        var file = exist ? xlsx.fromFileAsync(file_path) : xlsx.fromBlankAsync();\r\n        file.then(function(workbook){\r\n            try{\r\n                util.get_or_create_sheet(workbook, sheet_index_or_name, exist).cell(cell_address).value(data);\r\n            }catch(err){\r\n                reject(err);\r\n            };\r\n            \r\n            var toFile = workbook.toFileAsync(file_path);\r\n            toFile.then(function(){\r\n                return resolve();\r\n            });\r\n            toFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        });\r\n        file.catch(function(err){\r\n            return reject(err);\r\n        });\r\n    });\r\n}));",
            "DataName": "ExcelWriteToCell",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar data = [[XLSX_NODE_PARAMETERS]][2];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    data = util.format_data(data);\r\n    fs.exists(file_path, function(exist){\r\n        var file = exist ? xlsx.fromFileAsync(file_path) : xlsx.fromBlankAsync();\r\n        file.then(function(workbook){\r\n            try{\r\n                util.get_or_create_sheet(workbook, sheet_index_or_name, exist).cell(\"A1\").value(data);\r\n            }catch(err){\r\n                reject(err);\r\n            };\r\n            \r\n            var toFile = workbook.toFileAsync(file_path);\r\n            toFile.then(function(){\r\n                return resolve();\r\n            });\r\n            toFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        });\r\n        file.catch(function(err){\r\n            return reject(err);\r\n        });\r\n    });\r\n}));",
            "DataName": "ExcelWriteToSheet",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst RichText = require('xlsx-Populate').RichText;\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar from_row = [[XLSX_NODE_PARAMETERS]][2];\r\nvar to_row = [[XLSX_NODE_PARAMETERS]][3];\r\nvar data_format = [[XLSX_NODE_PARAMETERS]][4];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        var list = [];\r\n                        var usedRange = sheet.usedRange();\r\n                        if(usedRange){\r\n                            var endCell = usedRange.endCell();\r\n                            var endColumn = endCell.columnNumber();\r\n                            var endRow = endCell.rowNumber();\r\n                            from_row = from_row===0 ? endRow : (from_row==\"\" ? 1 : from_row);\r\n                            to_row = (to_row===0 || to_row==\"\") ? endRow : to_row;\r\n                            var range = sheet.range(from_row, 1, to_row, endColumn);\r\n                            list = range ? range.map(function(cell){return (cell.value() instanceof RichText) ? cell.value().text() : (typeof cell.value()===\"object\" ? \"\" : cell.value())}) : [];\r\n                        };\r\n                        [[XLSX_NODE_PARAMETERS]] = util.format_results(list, data_format);\r\n                    }else{\r\n                        reject('Sheet ' + JSON.stringify(sheet_index_or_name) + ' does not exist');\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                return resolve();\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            reject('The file \"' + file_path + '\" does not exist');\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelReadRows",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar from_row = [[XLSX_NODE_PARAMETERS]][2];\r\nvar data = [[XLSX_NODE_PARAMETERS]][3];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    data = util.format_data(data);\r\n    fs.exists(file_path, function(exist){\r\n        var file = exist ? xlsx.fromFileAsync(file_path) : xlsx.fromBlankAsync();\r\n        file.then(function(workbook){\r\n            try{\r\n                var list = [];\r\n                var sheet = util.get_or_create_sheet(workbook, sheet_index_or_name, exist);\r\n                var usedRange = sheet.usedRange();\r\n                if(usedRange){\r\n                    var last_row = usedRange.endCell().rowNumber();\r\n                    if(from_row===0 || from_row==\"\"){\r\n                        last_row++;\r\n                        sheet.cell(\"A\" + last_row).value(data);\r\n                    }else{\r\n                        var first_row = usedRange.startCell().rowNumber();\r\n                        if(last_row<from_row || from_row<first_row){\r\n                            sheet.cell(\"A\" + from_row).value(data);\r\n                        }else{\r\n                            last_row++;\r\n                            sheet.cell(\"A\" + last_row).value(data);\r\n                            var ready_data = sheet._rows.splice(last_row);\r\n                            sheet._rows.splice(from_row, 0, ...ready_data);\r\n                            sheet._rows.map(function(row, index){\r\n                                row._node.attributes.r = index;\r\n                                return row;\r\n                            });\r\n                        };\r\n                    };\r\n                }else{\r\n                    if(from_row===0 || from_row==\"\"){\r\n                        sheet.cell(\"A1\").value(data);\r\n                    }else{\r\n                        sheet.cell(\"A\" + from_row).value(data);\r\n                    };\r\n                };\r\n            }catch(err){\r\n                reject(err);\r\n            };\r\n\r\n            var toFile = workbook.toFileAsync(file_path);\r\n            toFile.then(function(){\r\n                return resolve();\r\n            });\r\n            toFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        });\r\n        file.catch(function(err){\r\n            return reject(err);\r\n        });\r\n    });\r\n}));",
            "DataName": "ExcelInsertRows",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar from_row = [[XLSX_NODE_PARAMETERS]][2];\r\nvar to_row = [[XLSX_NODE_PARAMETERS]][3];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        var usedRange = sheet.usedRange();\r\n                        if(usedRange){\r\n                            var endCell = usedRange.endCell();\r\n                            var endRow = endCell.rowNumber();\r\n                            from_row = from_row===0 ? endRow : (from_row==\"\" ? 1 : from_row);\r\n                            if(to_row===0 || to_row==\"\"){\r\n                                sheet._rows.splice(from_row);\r\n                            }else{\r\n                                var count = (to_row-from_row)+1;\r\n                                sheet._rows.splice(from_row, count);\r\n                            };\r\n                            sheet._rows.map(function(row, index){\r\n                                row._node.attributes.r = index;\r\n                                return row;\r\n                            });\r\n                        }else{\r\n                            resolve();\r\n                        };\r\n                    }else{\r\n                        resolve();\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                var toFile = workbook.toFileAsync(file_path);\r\n                toFile.then(function(){\r\n                    return resolve();\r\n                });\r\n                toFile.catch(function(err){\r\n                    return reject(err);\r\n                });\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            resolve();\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelDeleteRows",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst RichText = require('xlsx-Populate').RichText;\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar from_cell = [[XLSX_NODE_PARAMETERS]][2];\r\nvar to_cell = [[XLSX_NODE_PARAMETERS]][3];\r\nvar data_format = [[XLSX_NODE_PARAMETERS]][4];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        var range = sheet.range(from_cell, to_cell);\r\n                        var list = range ? range.map(function(cell){return (cell.value() instanceof RichText) ? cell.value().text() : (typeof cell.value()===\"object\" ? \"\" : cell.value())}) : [];\r\n                        [[XLSX_NODE_PARAMETERS]] = util.format_results(list, data_format);\r\n                    }else{\r\n                        reject('Sheet ' + JSON.stringify(sheet_index_or_name) + ' does not exist');\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                return resolve();\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            reject('The file \"' + file_path + '\" does not exist');\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelReadCellsRange",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar from_cell = [[XLSX_NODE_PARAMETERS]][2];\r\nvar data = [[XLSX_NODE_PARAMETERS]][3];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    data = util.format_data(data);\r\n    fs.exists(file_path, function(exist){\r\n        var file = exist ? xlsx.fromFileAsync(file_path) : xlsx.fromBlankAsync();\r\n        file.then(function(workbook){\r\n            try{\r\n                util.get_or_create_sheet(workbook, sheet_index_or_name, exist).cell(from_cell).value(data);\r\n            }catch(err){\r\n                reject(err);\r\n            };\r\n            \r\n            var toFile = workbook.toFileAsync(file_path);\r\n            toFile.then(function(){\r\n                return resolve();\r\n            });\r\n            toFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        });\r\n        file.catch(function(err){\r\n            return reject(err);\r\n        });\r\n    });\r\n}));",
            "DataName": "ExcelWriteToCellsRange",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar cell_address = [[XLSX_NODE_PARAMETERS]][2];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        var cell = sheet.cell(cell_address);\r\n                        cell ? cell.clear() : resolve();\r\n                    }else{\r\n                        reject('Sheet ' + JSON.stringify(sheet_index_or_name) + ' does not exist');\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                var toFile = workbook.toFileAsync(file_path);\r\n                toFile.then(function(){\r\n                    return resolve();\r\n                });\r\n                toFile.catch(function(err){\r\n                    return reject(err);\r\n                });\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            resolve()\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelClearCell",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar from_cell = [[XLSX_NODE_PARAMETERS]][2];\r\nvar to_cell = [[XLSX_NODE_PARAMETERS]][3];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        var range = sheet.range(from_cell, to_cell);\r\n                        range ? range.clear() : resolve();\r\n                    }else{\r\n                        reject('Sheet ' + JSON.stringify(sheet_index_or_name) + ' does not exist');\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                var toFile = workbook.toFileAsync(file_path);\r\n                toFile.then(function(){\r\n                    return resolve();\r\n                });\r\n                toFile.catch(function(err){\r\n                    return reject(err);\r\n                });\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            return resolve();\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelClearCellsRange",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        var usedRange = sheet.usedRange();\r\n                        usedRange ? usedRange.clear() : resolve();\r\n                    }else{\r\n                        resolve();\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                var toFile = workbook.toFileAsync(file_path);\r\n                toFile.then(function(){\r\n                    return resolve();\r\n                });\r\n                toFile.catch(function(err){\r\n                    return reject(err);\r\n                });\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            resolve();\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelClearSheet",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar contains = [[XLSX_NODE_PARAMETERS]][2];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    [[XLSX_NODE_PARAMETERS]] = sheet ? sheet.find(contains).map(function(cell){return (cell.columnNumber()-1) + \"*\" + (cell.rowNumber()-1)}) : [];\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                return resolve();\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            [[XLSX_NODE_PARAMETERS]] = [];\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelFindCells",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar cell_address = [[XLSX_NODE_PARAMETERS]][2];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        var formula = sheet.cell(cell_address).formula();\r\n                        [[XLSX_NODE_PARAMETERS]] = (typeof formula==\"undefined\") ? \"\" : formula;\r\n                    }else{\r\n                        reject('Sheet ' + JSON.stringify(sheet_index_or_name) + ' does not exist');\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                return resolve();\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            reject('The file \"' + file_path + '\" does not exist');\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelGetFormulaFromCell",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar cell_address = [[XLSX_NODE_PARAMETERS]][2];\r\nvar formula = [[XLSX_NODE_PARAMETERS]][3];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        var file = exist ? xlsx.fromFileAsync(file_path) : xlsx.fromBlankAsync();\r\n        file.then(function(workbook){\r\n            try{\r\n                util.get_or_create_sheet(workbook, sheet_index_or_name, exist).cell(cell_address).formula(formula);\r\n            }catch(err){\r\n                reject(err);\r\n            };\r\n            \r\n            var toFile = workbook.toFileAsync(file_path);\r\n            toFile.then(function(){\r\n                return resolve();\r\n            });\r\n            toFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        });\r\n        file.catch(function(err){\r\n            return reject(err);\r\n        });\r\n    });\r\n}));",
            "DataName": "ExcelSetFormulaToCell",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar cell_address = [[XLSX_NODE_PARAMETERS]][2];\r\nvar style_name = [[XLSX_NODE_PARAMETERS]][3];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        var style_value = sheet.cell(cell_address).style(style_name);\r\n                        [[XLSX_NODE_PARAMETERS]] = (typeof style_value==\"undefined\") ? \"\" : style_value;\r\n                    }else{\r\n                        reject('Sheet ' + JSON.stringify(sheet_index_or_name) + ' does not exist');\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                return resolve();\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            reject('The file \"' + file_path + '\" does not exist');\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelGetCellStyle",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheets = workbook.sheets();\r\n                    [[XLSX_NODE_PARAMETERS]] = sheets.map(function(sheet){return sheet.name()});\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                return resolve();\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            reject('The file \"' + file_path + '\" does not exist');\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelGetSheetsList",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar cell_address = [[XLSX_NODE_PARAMETERS]][2];\r\nvar styles_name_list = [[XLSX_NODE_PARAMETERS]][3];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        var styles_object = sheet.cell(cell_address).style(styles_name_list);\r\n                        [[XLSX_NODE_PARAMETERS]] = styles_object ? styles_object : {};\r\n                    }else{\r\n                        reject('Sheet ' + JSON.stringify(sheet_index_or_name) + ' does not exist');\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                return resolve();\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            reject('The file \"' + file_path + '\" does not exist');\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelGetCellStyles",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar cell_address = [[XLSX_NODE_PARAMETERS]][2];\r\nvar style_name = [[XLSX_NODE_PARAMETERS]][3];\r\nvar style_value = [[XLSX_NODE_PARAMETERS]][4];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        var file = exist ? xlsx.fromFileAsync(file_path) : xlsx.fromBlankAsync();\r\n        file.then(function(workbook){\r\n            try{\r\n                util.get_or_create_sheet(workbook, sheet_index_or_name, exist).cell(cell_address).style(style_name, style_value);\r\n            }catch(err){\r\n                reject(err);\r\n            };\r\n            \r\n            var toFile = workbook.toFileAsync(file_path);\r\n            toFile.then(function(){\r\n                return resolve();\r\n            });\r\n            toFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        });\r\n        file.catch(function(err){\r\n            return reject(err);\r\n        });\r\n    });\r\n}));",
            "DataName": "ExcelSetStyleToCell",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar cell_address = [[XLSX_NODE_PARAMETERS]][2];\r\nvar styles = [[XLSX_NODE_PARAMETERS]][3];\r\nstyles = (typeof styles==\"object\") ? styles : JSON.parse(styles);\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        var file = exist ? xlsx.fromFileAsync(file_path) : xlsx.fromBlankAsync();\r\n        file.then(function(workbook){\r\n            try{\r\n                util.get_or_create_sheet(workbook, sheet_index_or_name, exist).cell(cell_address).style(styles);\r\n            }catch(err){\r\n                reject(err);\r\n            };\r\n            \r\n            var toFile = workbook.toFileAsync(file_path);\r\n            toFile.then(function(){\r\n                return resolve();\r\n            });\r\n            toFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        });\r\n        file.catch(function(err){\r\n            return reject(err);\r\n        });\r\n    });\r\n}));",
            "DataName": "ExcelSetStylesToCell",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar from_cell = [[XLSX_NODE_PARAMETERS]][2];\r\nvar to_cell = [[XLSX_NODE_PARAMETERS]][3];\r\nvar style_name = [[XLSX_NODE_PARAMETERS]][4];\r\nvar style_value = [[XLSX_NODE_PARAMETERS]][5];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        var file = exist ? xlsx.fromFileAsync(file_path) : xlsx.fromBlankAsync();\r\n        file.then(function(workbook){\r\n            try{\r\n                util.get_or_create_sheet(workbook, sheet_index_or_name, exist).range(from_cell, to_cell).style(style_name, style_value);\r\n            }catch(err){\r\n                reject(err);\r\n            };\r\n            \r\n            var toFile = workbook.toFileAsync(file_path);\r\n            toFile.then(function(){\r\n                return resolve();\r\n            });\r\n            toFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        });\r\n        file.catch(function(err){\r\n            return reject(err);\r\n        });\r\n    });\r\n}));",
            "DataName": "ExcelSetStyleToCellsRange",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar from_cell = [[XLSX_NODE_PARAMETERS]][2];\r\nvar to_cell = [[XLSX_NODE_PARAMETERS]][3];\r\nvar styles = [[XLSX_NODE_PARAMETERS]][4];\r\nstyles = (typeof styles==\"object\") ? styles : JSON.parse(styles);\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        var file = exist ? xlsx.fromFileAsync(file_path) : xlsx.fromBlankAsync();\r\n        file.then(function(workbook){\r\n            try{\r\n                util.get_or_create_sheet(workbook, sheet_index_or_name, exist).range(from_cell, to_cell).style(styles);\r\n            }catch(err){\r\n                reject(err);\r\n            };\r\n            \r\n            var toFile = workbook.toFileAsync(file_path);\r\n            toFile.then(function(){\r\n                return resolve();\r\n            });\r\n            toFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        });\r\n        file.catch(function(err){\r\n            return reject(err);\r\n        });\r\n    });\r\n}));",
            "DataName": "ExcelSetStylesToCellsRange",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst RichText = require('xlsx-Populate').RichText;\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        var list = [];\r\n                        var usedRange = sheet.usedRange();\r\n                        if(usedRange){\r\n                            var endCell = usedRange.endCell();\r\n                            var endColumn = endCell.columnNumber();\r\n                            var endRow = endCell.rowNumber();\r\n                            var range = sheet.range(1, 1, endRow, endColumn);\r\n                            list = range ? range.value() : [];\r\n                        };\r\n                        [[XLSX_NODE_PARAMETERS]] = list.length;\r\n                    }else{\r\n                        reject('Sheet ' + JSON.stringify(sheet_index_or_name) + ' does not exist');\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                return resolve();\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            reject('The file \"' + file_path + '\" does not exist');\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelCountRows",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst RichText = require('xlsx-Populate').RichText;\r\nconst fs = require('fs');\r\nconst util = require(\"../ExcelUtil\");\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar data_format = [[XLSX_NODE_PARAMETERS]][2];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var sheet = workbook.sheet(sheet_index_or_name);\r\n                    if(sheet){\r\n                        var list = [];\r\n                        var usedRange = sheet.usedRange();\r\n                        if(usedRange){\r\n                            var endCell = usedRange.endCell();\r\n                            var endColumn = endCell.columnNumber();\r\n                            var endRow = endCell.rowNumber();\r\n                            var range = sheet.range(1, 1, endRow, endColumn);\r\n                            list = range ? range.map(function(cell){return (cell.value() instanceof RichText) ? cell.value().text() : (typeof cell.value()===\"object\" ? \"\" : cell.value())}) : [];\r\n                        };\r\n                        [[XLSX_NODE_PARAMETERS]] = util.format_results(list, data_format);\r\n                    }else{\r\n                        reject('Sheet ' + JSON.stringify(sheet_index_or_name) + ' does not exist');\r\n                    };\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                return resolve();\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            reject('The file \"' + file_path + '\" does not exist');\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelReadSheet",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        var file = exist ? xlsx.fromFileAsync(file_path) : xlsx.fromBlankAsync();\r\n        file.then(function(workbook){\r\n            if(exist){\r\n                try{\r\n                    var sheets_list = workbook.sheets();\r\n                    sheets_list.forEach(function(sheet){\r\n                        var usedRange = sheet.usedRange();\r\n                        usedRange ? usedRange.clear() : \"\";\r\n                    });\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n            };\r\n            \r\n            var toFile = workbook.toFileAsync(file_path);\r\n            toFile.then(function(){\r\n                return resolve();\r\n            });\r\n            toFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        });\r\n        file.catch(function(err){\r\n            return reject(err);\r\n        });\r\n    });\r\n}));",
            "DataName": "ExcelCreateFile",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const xlsx = require('xlsx-populate');\r\nconst fs = require('fs');\r\nvar file_path = [[XLSX_NODE_PARAMETERS]][0];\r\nvar sheet_index_or_name = [[XLSX_NODE_PARAMETERS]][1];\r\nvar contains = [[XLSX_NODE_PARAMETERS]][2];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    fs.exists(file_path, function(exist){\r\n        if(exist){\r\n            var fromFile = xlsx.fromFileAsync(file_path);\r\n            fromFile.then(function(workbook){\r\n                try{\r\n                    var found_cell = [\"\", \"\", \"\"];\r\n                    if(sheet_index_or_name!==\"\"){\r\n                        var sheet = workbook.sheet(sheet_index_or_name);\r\n                        var cells = sheet ? sheet.find(contains) : [];\r\n                        if(cells.length!==0){\r\n                            var cell = cells[0];\r\n                            found_cell[0] = cell.columnNumber() - 1;\r\n                            found_cell[1] = cell.rowNumber() - 1;\r\n                            found_cell[2] = sheet_index_or_name;\r\n                        };\r\n                    }else{\r\n                        var sheets = workbook.sheets();\r\n                        sheets.forEach(function(sheet, index){\r\n                            var cells = sheet.find(contains);\r\n                            if(cells.length!==0){\r\n                                var cell = cells[0];\r\n                                found_cell[0] = cell.columnNumber() - 1;\r\n                                found_cell[1] = cell.rowNumber() - 1;\r\n                                found_cell[2] = index;\r\n                                return;\r\n                            };\r\n                        });\r\n                    };\r\n                    [[XLSX_NODE_PARAMETERS]] = found_cell;\r\n                }catch(err){\r\n                    reject(err);\r\n                };\r\n                \r\n                return resolve();\r\n            });\r\n            fromFile.catch(function(err){\r\n                return reject(err);\r\n            });\r\n        }else{\r\n            [[XLSX_NODE_PARAMETERS]] = [];\r\n        };\r\n    });\r\n}));",
            "DataName": "ExcelFindCell",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "var self = this;\n\nthis.csv_generate = function(list, separator=\",\"){\n    var res = '';\n    var first = true;\n    list.forEach(function(item=\"\"){\n        item = typeof item[\"_error\"]===\"undefined\" ? item : \"\";\n        var add = item;\n        if(typeof item!==\"number\" && typeof item!==\"boolean\" && (item.indexOf(\";\") > -1 || item.indexOf(\":\") > -1 || item.indexOf(\",\") > -1 || item.indexOf(separator) > -1)){\n            add = \"\\\"\" + add.replace(/[\"]/gi, \"\\\"\\\"\") + \"\\\"\";\n        };\n        if(!first){\n            res += separator;\n        }else{\n            first = false;\n        };\n        res += add;\n    });\n    return res;\n};\nthis.csv_parse = function(line){\n    var res = [];\n    var index = 0;\n    var len = line.length;\n    var InsideQuotes = false;\n    var CurrentElement = '';\n    \n    while(index<len){\n        var c = line[index];\n        var n = '';\n        var HasNext = (index + 1) < len;\n        if(HasNext){\n            n = line[index + 1];\n        };\n        index++;\n\n        if(c=='\\\"'){\n            if(InsideQuotes){\n                if(!HasNext || n!='\\\"'){\n                    InsideQuotes = false;\n                    continue;\n                }else{\n                    CurrentElement += \"\\\"\";\n                    index++;\n                    continue;\n                }\n            }else{\n                InsideQuotes = true;\n                continue;\n            }\n        };\n\n        if(c==':' || c==';' || c==','){\n            if(InsideQuotes){\n                CurrentElement += c;\n                continue;\n            }else{\n                res.push(self.convert(CurrentElement));\n                CurrentElement = '';\n                continue;\n            }\n        };\n        CurrentElement += c;\n    };\n    res.push(self.convert(CurrentElement));\n\n    return res;\n};\nthis.date_to_number = function(date){\n    var date_only = new Date(date.getTime());\n    date_only.setHours(0, 0, 0, 0);\n    var date_base = new Date(1900, 0, 0);\n    var incorrect_leap_date = new Date(1900, 1, 28);\n    var milliseconds_in_day = 1000 * 60 * 60 * 24;\n    var number = Math.round((date_only - date_base) / milliseconds_in_day);\n    number += (date - date_only) / milliseconds_in_day;\n    if(date > incorrect_leap_date){number += 1};\n    return number;\n};\nthis.date_check = function(data){\n\tvar date = new Date(data);\n\treturn date=='Invalid Date' ? data : self.date_to_number(date);\n};\nthis.convert = function(data){\n    return (typeof data===\"string\" && data!==\"\") ? (isNaN(data) ? (data===\"true\" || data===\"false\" ? data===\"true\" : self.date_check(data)) : Number(data)) : data;\n};\nthis.replace_null = function(rows){\n    return rows.map(function(row){return row.map(function(cell){return (cell==null) ? \"\" : cell})})\n};\nthis.format_data = function(data){\n    if(data.length!==0){\n        if(typeof data!==\"object\"){\n            data = data.split(/\\r?\\n/);\n        };\n        data = data.map(function(row){return (typeof row!==\"object\") ? self.csv_parse(row) : row.map(function(cell){return self.convert(cell)})});\n\t\treturn self.replace_null(data);\n    }else{\n\t\treturn \"\";\n\t};\n};\nthis.format_results = function(results, format){\n    results = self.replace_null(results);\n    if(format==\"CSV list\" || format==\"CSV string\"){\n        results = results.map(function(row){return self.csv_generate(row, \":\")});\n        if(format==\"CSV string\"){\n            results = results.join(\"\\n\");\n        };\n    };\n    return results;\n};\nthis.get_or_create_sheet = function(workbook, sheet_index_or_name, exist){\n    var sheet = workbook.sheet(sheet_index_or_name);\n    if(!sheet){\n        var sheet_name = \"\";\n        var sheet_index = \"\";\n        if(typeof sheet_index_or_name==\"number\"){\n            sheet_name = \"NewSheet\" + Math.floor(Math.random() * 100) + 1;\n            sheet_index = sheet_index_or_name;\n        }else{\n            sheet_name = sheet_index_or_name;\n            sheet_index = null;\n        };\n        sheet = exist ? workbook.addSheet(sheet_name, sheet_index) : (sheet_index ? workbook.addSheet(sheet_name, sheet_index) : workbook.sheet(0).name(sheet_name));\n    };\n    return sheet;\n};",
            "DataName": "ExcelUtil",
            "DataType": 1,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        }
    ],
    "engine": [
        "engine.js"
    ],
    "icon": "Excel.png",
    "info": {
        "en": "Module for working with excel files.",
        "ru": "Модуль для работы с excel файлами."
    },
    "is_autogenerated": true,
    "languages": [
        {
            "Name": "Node",
            "Version": "12.18.3"
        }
    ],
    "localize": {
		"Styles": {"ru":"Стили"},
		"Numbеr": {"ru":"Число"},
		"Sheet1": {"ru":"Лист1"},
		"Sheet2": {"ru":"Лист2"},
		"Analog": {"ru":"Аналог"},
		"String": {"ru":"Строка"},
		"is empty": {"ru":"пуст"},
		"Formula": {"ru":"Формула"},
		"Count": {"ru":"Количество"},
		"To row": {"ru":"До строки"},
		"To cell": {"ru":"До ячейки"},
		"From row": {"ru":"Со строки"},
		"From cell": {"ru":"С ячейки"},
		"New Sheet": {"ru":"Новый лист"},
		"Sheet name": {"ru":"Имя листа"},
		"File path": {"ru":"Путь к файлу"},
		"First row": {"ru":"Первая строка"},
		"JSON string": {"ru":"JSON строка"},
		"Second row": {"ru":"Вторая строка"},
		"Sheet index": {"ru":"Индекс листа"},
		"Last row": {"ru":"Последняя строка"},
		"Style name": {"ru":"Название стиля"},
		"Data format": {"ru":"Формат данных"},
		"Cell address": {"ru":"Адрес ячейки"},
		"Style value": {"ru":"Значение стиля"},
		"First column": {"ru":"Первый столбец"},
		"Second column": {"ru":"Второй столбец"},
		"List of sheets": {"ru":"Список листов"},
		"Cell contains": {"ru":"Ячейка содержит"},
		"Can be blank": {"ru":"Может быть пустым"},
		"Cells contains": {"ru":"Ячейки содержат"},
		"New sheet name.": {"ru":"Новое имя листа."},
		"Subscript text": {"ru":"Подстрочный текст"},
		"Cell not found": {"ru":"Ячейка не найдена"},
		"Cells not found": {"ru":"Ячейки не найдены"},
		"New sheet index": {"ru":"Новый индекс листа"},
		"Superscript text": {"ru":"Надстрочный текст"},
		"First sheet name": {"ru":"Имя первого листа"},
		"Underline text": {"ru":"Подчеркивание текста"},
		"Second sheet name": {"ru":"Имя второго листа"},
		"Style Reference": {"ru":"Справочника по стилям"},
		"Bold text": {"ru":"Полужирное начертание текста"},
		"First sheet index": {"ru":"Индекс первого листа"},
		"Strikethrough text": {"ru":"Зачеркивание текста"},
		"Italic text": {"ru":"Курсивное начертание текста"},
		"Style names list": {"ru":"Список названий стилей"},
		"Second sheet index": {"ru":"Индекс второго листа"},
		"Sheet index or name": {"ru":"Индекс или имя листа"},
		"List of resource names": {"ru":"Список имен ресурсов"},
		"The path to the excel file.": {"ru":"Путь к excel файлу."},
		"Insert at the end of the sheet": {"ru":"Вставить в конец листа"},
		"First column, first row": {"ru":"Первый столбец, первая строка"},
		"Second column, second row": {"ru":"Второй столбец, вторая строка"},
		"All sheets will be imported": {"ru":"Все листы будут импортированы"},
		"Row index of the found cell": {"ru":"Индекс строки найденной ячейки"},
		"Clear sheet from excel file.": {"ru":"Очистить лист из excel файла."},
		"Sheet index of the found cell": {"ru":"Индекс листа найденной ячейки"},
		"Up to and including first row": {"ru":"До первой строки включительно"},
		"Create or clear excel file.": {"ru":"Создать или очистить excel файл."},
		"Up to and including second row": {"ru":"До второй строки включительно"},
		"Up to and including last row": {"ru":"До последней строки включительно"},
		"Add new sheet to excel file.": {"ru":"Добавить новый лист в excel файл."},
		"Column index of the found cell": {"ru":"Индекс столбца найденной ячейки"},
		"Search all sheets of excel file": {"ru":"Поиск по всем листам excel файла"},
		"Variable to save the result": {"ru":"Переменная, в которую сохранить результат"},
		"Index or sheet name in excel file.": {"ru":"Индекс или имя листа в excel файле."},
		"Read entire sheet from an excel file.": {"ru":"Читать весь лист из excel файла."},
		"Cell address in the excel file sheet.": {"ru":"Адрес ячейки на листе excel файла."},
		"Write data to sheet in excel file.": {"ru":"Записать данные на лист в excel файле."},
		"The sheet will have the specified index": {"ru":"Лист будет иметь указанный индекс"},
		"The number of rows to be deleted.": {"ru":"Количество строк, которое будет удалено."},
		"Get list of sheets from excel file.": {"ru":"Получить список листов из excel файла."},
		"The ending cell address in excel file.": {"ru":"Адрес конечной ячейки в excel файле."},
		"Insert rows in specified excel file.": {"ru":"Вставить строки в указанный excel файл."},
		"Move specified sheet in excel file.": {"ru":"Переместить указанный лист в excel файле."},
		"Read cell from specified excel file.": {"ru":"Читать ячейку из указанного excel файла."},
		"Read rows from specified excel file.": {"ru":"Читать строки из указанного excel файла."},
		"The data which will be searched.": {"ru":"Данные, по которым будет производиться поиск."},
		"The starting cell address in excel file.": {"ru":"Адрес начальной ячейки в excel файле."},
		"Delete specified sheet from excel file.": {"ru":"Удалить указанный лист из excel файла."},
		"The rows data which needs to be inserted.": {"ru":"Данные строк, которые нужно вставить."},
		"Row index from which reading starts.": {"ru":"Индекс строки, с которой начинается чтение."},
		"Clear cell from specified excel file.": {"ru":"Очистить ячейку из указанного excel файла."},
		"Delete rows from specified excel file.": {"ru":"Удалить строки из указанного excel файла."},
		"The style value which needs to be set.": {"ru":"Значение стиля, которое нужно установить."},
		"The sheet will be added to the end of the book": {"ru":"Лист будет добавлен в конец книги"},
		"The sheet will be moved to the end of the book": {"ru":"Лист будет перемещен в конец книги"},
		"Cell address from which reading starts.": {"ru":"Адрес ячейки, с которой начинается чтение."},
		"Cell address from which writing starts.": {"ru":"Адрес ячейки, с которой начинается запись."},
		"Row index from which deleting starts.": {"ru":"Индекс строки, с которой начинается удаление."},
		"Row index from which inserting starts.": {"ru":"Индекс строки, с которой начинается вставка."},
		"Cell address from which cleaning starts.": {"ru":"Адрес ячейки, с которой начинается очистка."},
		"Rename the specified sheet in excel file.": {"ru":"Переименовать указанный лист в excel файле."},
		"Row index after which reading ends.": {"ru":"Индекс строки, после которой заканчивается чтение."},
		"Cell address after which reading ends.": {"ru":"Адрес ячейки, после которой заканчивается чтение."},
		"Row index after which deleting ends.": {"ru":"Индекс строки, после которой заканчивается удаление."},
		"Export data from resources to excel file.": {"ru":"Экспортировать данные из ресурсов в excel файл."},
		"Cell address after which cleaning ends.": {"ru":"Адрес ячейки, после которой заканчивается очистка."},
		"For details on the supported styles, see": {"ru":"Подробнее о поддерживаемых стилях можно узнать из"},
		"Import data from excel file into resources.": {"ru":"Импортировать данные из excel файла в ресурсы."},
		"Read cells range from specified excel file.": {"ru":"Читать область ячеек из указанного excel файла."},
		"Write data to cell on specified excel file.": {"ru":"Записать данные в ячейку указанного excel файла."},
		"Each cell from specified sheet will be cleared.": {"ru":"Каждая ячейка указанного листа будет очищена."},
		"The sheet will be added before the specified sheet": {"ru":"Лист будет добавлен перед указанным листом"},
		"Clear cells range from specified excel file.": {"ru":"Очистить область ячеек из указанного excel файла."},
		"Convert data from excel file to JSON string.": {"ru":"Преобразовать данные из excel файла в JSON строку."},
		"Returns the largest value in cells E1 to H1": {"ru":"Возвращает наибольшее значение в ячейках от E1 до H1"},
		"The sheet will be placed in before the specified sheet": {"ru":"Лист будет помещен перед указанным листом"},
		"Get formula from cell in specified excel file.": {"ru":"Получить формулу из ячейки указанного excel файла."},
		"Returns the smallest number in cells E1 to H1": {"ru":"Возвращает наименьшее значение в ячейках от E1 до H1"},
		"Find all cells by their content in excel file.": {"ru":"Найдите все ячейки в excel файле по их содержимому."},
		"Find single cell by its content in excel file.": {"ru":"Найдите одну ячейку в excel файле по ее содержимому."},
		"Calculates the sum of all numbers in cells E1 to H1": {"ru":"Вычисляет сумму всех чисел в ячейках от E1 до H1"},
		"Set formula to cell from specified excel file.": {"ru":"Установить формулу в ячейку из указанного excel файла."},
		"JSON string containing style names and values.": {"ru":"JSON строка, содержащая названия стилей и их значения."},
		"List of style names which needs to get values.": {"ru":"Список названий стилей, значения которых нужно получить."},
		"Get cell style value from specified excel file.": {"ru":"Получить значение стиля ячейки из указанного excel файла."},
		"Write data to cells range on specified excel file.": {"ru":"Записать данные в область ячеек указанного excel файла."},
		"If the file or sheet is missing, no error will occur.": {"ru":"Если файл или лист отсутствуют, ошибки не произойдет."},
		"Get cell styles values from specified excel file.": {"ru":"Получить значения стилей ячейки из указанного excel файла."},
		"The data which needs to be written to the specified cell.": {"ru":"Данные, которые нужно записать в указанную ячейку."},
		"The data which needs to be written to the specified sheet.": {"ru":"Данные, которые нужно записать на указанный лист."},
		"The name of the style which needs to set a value for.": {"ru":"Название стиля, для которого нужно установить значение."},
		"JSON string which needs to be converted to excel file.": {"ru":"JSON строка, которую нужно преобразовать в excel файл."},
		"The name of the style, which needs the value to be obtained.": {"ru":"Название стиля, значение которого нужно получить."},
		"The data that is contained in the cells to be found.": {"ru":"Данные которые содержатся в ячейках, которые нужно найти."},
		"Rows following the deleted rows will be shifted up.": {"ru":"Строки, идущие после удаляемых строк, будут смещены вверх."},
		"The formula which needs to be set to the specified cell.": {"ru":"Формула, которую нужно установить в указанную ячейку."},
		"Set style value for cell on specified excel file.": {"ru":"Установить значение стиля для ячейки на указанном excel файла."},
		"Set styles values ​​for cell from specified excel file.": {"ru":"Установить значения стилей для ячейки из указанного excel файла."},
		"Get the number of rows in a specified sheet of an excel file.": {"ru":"Получить количество строк на указанном листе excel файла."},
		"Convert data from JSON string and write it to excel file.": {"ru":"Преобразовать данные из JSON строки и записать их в excel файл."},
		"The data which needs to be written to the specified cells range.": {"ru":"Данные, которые нужно записать в указанную область ячеек."},
		"If the cell is not found, the action will return empty strings.": {"ru":"Если ячейка не будет найдена, действие вернет пустые строки."},
		"The format in which the read data will be saved to variable.": {"ru":"Формат, в котором прочитанные данные будут сохранены в переменную."},
		"Lists can be processed using actions from the \"List\" module.": {"ru":"Списки можно обработать с помощью действий из модуля \"Список\"."},
		"Set style value for cells range from specified excel file.": {"ru":"Установить значение стиля для области ячеек из указанного excel файла."},
		"Set styles values ​​for cells range on specified excel file.": {"ru":"Установить значения стилей для области ячеек на указанном excel файла."},
		"Rows that are in the new rows insertion zone will be shifted down.": {"ru":"Строки, находящиеся в зоне вставки новых строк, будут смещены вниз."},
		"Old data that doesn't interact with new one will remain unchanged.": {"ru":"Старые данные, которые не взаимодействуют с новыми, останутся без изменений."},
		"The format of the saved data depends on the \"Data Format\" setting.": {"ru":"Формат сохраняемых данных зависит от значения параметра \"Формат данных\"."},
		"Column index from variable [[COLUMN]], row index from variable [[ROW]]": {"ru":"Индекс столбца из переменной [[COLUMN]], индекс строки из переменной [[ROW]]"},
		"(Value <code>true</code> for italic, <code>false</code> for not italic)": {"ru":"(Значение <code>true</code> для курсива, <code>false</code> для не курсива)"},
		"Returns the average (arithmetic mean) of the numbers in cells E1 to H1": {"ru":"Возвращает среднее значение (среднее арифметическое) чисел в ячейках от E1 до H1"},
		"(Value <code>true</code> for bold, <code>false</code> for not bold)": {"ru":"(Значение <code>true</code> для полужирного, <code>false</code> для не полужирного)"},
		"The resulting list will contain the names of all sheets in the excel file.": {"ru":"Полученный список будет содержать имена всех листов имеющихся в excel файле."},
		"The resulting list can be processed using actions from the \"List\" module.": {"ru":"Полученный список можно обработать с помощью действий из модуля \"Список\"."},
		"List of names of resources, data from which needs be exported to an excel file.": {"ru":"Список имен ресурсов, данные из которых нужно экспортировать в excel файл."},
		"The resulting JSON string can be processed using actions from the \"JSON\" module.": {"ru":"Полученную JSON строку можно обработать с помощью действий из модуля \"JSON\"."},
		"If the \"Sheet index\" parameter is empty, the sheet will be added to the end of the book.": {"ru":"Если параметр \"Индекс листа\" пуст, лист будет добавлен в конец книги."},
		"Old data that falls into the new data area will be overwritten with the new data.": {"ru":"Старые данные, попадающие в область новых данных, будут перезаписаны новыми данными."},
		"Data can be generated manually by using \"List\" module or \"Template\" action.": {"ru":"Данные можно сгенерировать вручную с помощью модуля \"Список\" или действия \"Шаблон\"."},
		"(Value <code>true</code> for strikethrough <code>false</code> for not strikethrough)": {"ru":"(Значение <code>true</code> для зачеркивания, <code>false</code> для не зачеркивания)"},
		"If the \"From row\" and \"To row\" parameters are not specified, all rows will be read.": {"ru":"Если параметры \"Со строки\" и \"До строки\" не указаны, будут прочитаны все строки."},
		"If the \"From row\" and \"To row\" parameters are not specified, all rows will be deleted.": {"ru":"Если параметры \"Со строки\" и \"До строки\" не указаны, будут удалены все строки."},
		"If the \"New sheet index\" parameter is empty, the sheet will be moved to the end of the book.": {"ru":"Если параметр \"Новый индекс листа\" пуст, лист будет перемещен в конец книги."},
		"CSV lines can be parsed using the \"Parse Line\" action from the \"Tools\" module.": {"ru":"CSV строки можно распарсить с помощью действия \"Парсить строку\" из модуля \"Инструменты\"."},
		"Variable in which, after successful execution of the action, a JSON string will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записана JSON строка."},
		"Variable in which, after successful execution of the action, the list of sheets will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записан список листов."},
		"Variable in which, after successful execution of the action, the number of rows will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записано количество строк."},
		"The index where the sheet should be placed, or the name of the sheet before which it should be placed.": {"ru":"Индекс, на который нужно поместить лист, или имя листа, перед которым его нужно поместить."},
		"This action accepts data in any of three formats: \"CSV list\", \"CSV string\", \"2D list\".": {"ru":"Данное действие принимает данные в любом из трех форматов: \"CSV list\", \"CSV string\", \"2D list\"."},
		"The index where the sheet should be moved, or the name of the sheet before which it should be placed.": {"ru":"Индекс, на который нужно переместить лист, или имя листа, перед которым его нужно поместить."},
		"Variable in which, after successful execution of the action, the contents of the rows will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записано содержимое строк."},
		"Variable in which, after successful execution of the action, the contents of the cell will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записано содержимое ячейки."},
		"Variable in which, after successful execution of the action, the contents of the cells will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записано содержимое ячеек."},
		"Variable in which, after successful execution of the action, the contents of the sheet will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записано содержимое листа."},
		"Variable in which, after successful execution of the action, the formula from the cell will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записана формула из ячейки."},
        "If a resource is specified in the \"File path\" parameter, resource location will be used.": {"ru":"Если в параметре \"Путь к файлу\" указан ресурс, вместо содержимого ресурса будет браться его расположение."},
		"List of indexes or names of sheets from excel file, data from which should be imported into resources.": {"ru":"Список индексов или имен листов из excel файла, данные из которых нужно импортировать в ресурсы."},
		"This action creates file if it does not already exist, and clears all sheets if file already exists.": {"ru":"Это действие создает файл, если он еще не существует, и очищает все листы, если файл уже существует."},
		"When specifying a sheet name in the \"Sheet index\" parameter, the field type must be <code>string</code>.": {"ru":"При указании имени листа в параметр \"Индекс листа\" тип поля должен быть <code>string</code>."},
		"Variable in which, after successful execution of the action, the value of the cell style will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записано значение стиля ячейки."},
		"When specifying a sheet name in the \"New sheet index\" parameter, the field type must be <code>string</code>.": {"ru":"При указании имени листа в параметр \"Новый индекс листа\" тип поля должен быть <code>string</code>."},
		"Variable in which, after successful execution of the action, the row index of the found cell will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записан индекс строки найденной ячейки."},
		"This action accepts styles as a JSON string, where key is the style name and value is the style value.": {"ru":"Данное действие принимает стили в виде JSON строки, где ключ - это название стиля, а значение - это значение стиля."},
		"Variable in which, after successful execution of the action, the column index of the found cell will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записан индекс столбца найденной ячейки."},
		"Variable in which, after successful execution of the action, the index of the sheet of the found cell will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записан индекс листа найденной ячейки."},
		"Variable in which, after successful execution of the action, the list of addresses of the found cells will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записан список адресов найденных ячеек."},
		"This action creates a resource from each specified sheet of the excel file that has the sheet name and its contents.": {"ru":"Данное действие создает ресурс из каждого указанного листа excel файла, имеющий название листа и его содержимое."},
		"Data in a suitable format can be obtained from the actions: \"Read sheet\", \"Read rows\", \"Read cells range\".": {"ru":"Данные в подходящем формате можно получить из действий: \"Читать лист\", \"Читать строки\", \"Читать область ячеек\"."},
		"In the \"Sheet index\" parameter, you can specify the name of an existing sheet, then a new sheet will be added before it.": {"ru":"В параметр \"Индекс листа\" можно указать имя уже существующего листа, тогда новый лист будет добавлен перед ним."},
		"To insert lines at the end of the sheet, use index <code>-1</code> in the \"From row\" parameter, or leave it blank.": {"ru":"Чтобы вставить строки в конец листа, используйте индекс <code>-1</code> в параметре \"Со строки\" или оставьте его пустым."},
		"This action creates a sheet in an excel file from each specified resource, having the name of the resource and its contents.": {"ru":"Данное действие создает лист в excel файле из каждого указанного ресурса, имеющий название ресурса и его содержимое."},
		"Formulas must be specified in English, a list of formulas in English and their translation from different languages can be found": {"ru":"Формулы нужно указывать на Английском языке, список формул на Английском и их перевод с разных языков можно найти"},
		"CSV string - this CSV lines separated by a line break, and consisting of cell values separated with \":\" symbol. Example: ": {"ru":"CSV string - это CSV строки, разделенные переносом строки и состоящие из значений ячеек, разделенных символом \":\". Пример: "},
		"In the \"New sheet index\" parameter, you can specify the name of an existing sheet, then the specified sheet will be placed in front of it.": {"ru":"В параметр \"Новый индекс листа\" можно указать имя существующего листа, тогда указанный лист будет помещен перед ним."},
		"This action save in variables the column, row and sheet indexes of the found cell or empty strings if the cell was not found.": {"ru":"Данное действие сохраняет в переменные индексы столбца, строки и листа найденной ячейки или пустые строки, если ячейка не была найдена."},
		"If the \"From row\" parameter is not specified and the \"To row\" parameter is specified, all rows from the first to the specified will be read.": {"ru":"Если параметр \"Со строки\" не указан, а параметр \"До строки\" указан, будут прочитаны все строки с первой до указанной."},
		"If the \"From row\" parameter is not specified and the \"To row\" parameter is specified, all rows from the first to the specified will be deleted.": {"ru":"Если параметр \"Со строки\" не указан, а параметр \"До строки\" указан, будут удалены все строки с первой до указанной."},
		"If the \"From row\" parameter is specified and the \"To row\" parameter is not specified, all rows from the specified to the last will be read.": {"ru":"Если параметр \"Со строки\" указан, а параметр \"До строки\" не указан, будут прочитаны все строки с указанной до последней."},
		"If the \"From row\" parameter is specified and the \"To row\" parameter is not specified, all rows from the specified to the last will be deleted.": {"ru":"Если параметр \"Со строки\" указан, а параметр \"До строки\" не указан, будут удалены все строки с указанной до последней."},
		"Variable in which, after successful execution of the action, a JSON string containing the names of the styles and their values will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записана JSON строка, содержащая названия стилей и их значения."},
		"Cell addresses can be parsed into column and row indexes by the \"*\" separator using the \"Parse String\" action from the \"List\" module.": {"ru":"Адреса ячеек можно распарсить на индексы столбца и строки, по разделителю \"*\" с помощью действия \"Парсить Строку\" из модуля \"Список\"."},
		"(Value <code>true</code> for single underline, <code>false</code> for no underline, <code>'double'</code> for double-underline)": {"ru":"(Значение <code>true</code> для одинарного подчеркивания, <code>false</code> для отсутствия подчеркивания, <code>'double'</code> для двойного подчеркивания)"},
		"Reading is performed up to and including row specified in \"To row\" parameter, to read one row, you need to specify its index in both parameters.": {"ru":"Чтение осуществляется включительно до строки, указанной в параметре \"До строки\", чтобы прочитать одну строку, нужно в оба параметра указать её индекс."},
		"Removing row is performed up to and including row specified in \"To row\" parameter. To delete one row, you need to specify its index in both parameters.": {"ru":"Удаление выполняется включительно до строки, указанной в параметре \"До строки\". Чтобы удалить одну строку, нужно в оба параметра указать её индекс."},
		"If an error occurred while execute action, the thread will stop with fail message. If you want to continue thread, use \"Ignore errors\" action.":{"ru":"Если во время выполнения действия произойдет ошибка, поток остановится с сообщением об ошибке. Если вы хотите продолжить работу, используйте действие \"Игнорировать ошибки\"."},
		"2D list - a list that consists of lists containing the cell values. Example: <code>[[\"A1\",\"B1\",\"C1\"],[\"A2\",\"B2\",\"C2\"],[\"A3\",\"B3\",\"C3\"]]</code>": {"ru":"2D list - это список, состоящий из списков, содержащих значения ячеек. Пример: <code>[[\"A1\",\"B1\",\"C1\"],[\"A2\",\"B2\",\"C2\"],[\"A3\",\"B3\",\"C3\"]]</code>"},
		"CSV list - a list that consists of CSV lines and CSV line consists of cell values separated with \":\" symbol. Example: <code>[\"A1:B1:C1\",\"A2:B2:C2\",\"A3:B3:C3\"]</code>": {"ru":"CSV list - это список, состоящий из CSV строк, а CSV строка состоит из значений ячеек, разделенных символом \":\". Пример: <code>[\"A1:B1:C1\",\"A2:B2:C2\",\"A3:B3:C3\"]</code>"},
		"This action returns a list of addresses of found cells, cell addresses consist of a column index and a row index separated with \"*\" symbol. Example: <code>[\"4*3\",\"2*6\",\"1*8\"]</code>": {"ru":"Данное действие возвращает список адресов найденных ячеек, адреса ячеек состоят из индекса столбца и индекса строки разделенных символом \"*\". Пример: <code>[\"4*3\",\"2*6\",\"1*8\"]</code>"},
		"You can specify a standard address with a column letter and row number, or the column index and row index separated by *. The column/row index is not equal to their number, because the index starts from 0, and the number starts from 1.": {"ru":"Можно указать стандартный адрес с буквой столбца и номером строки, или индекс столбца и индекс строки через разделитель *. Индекс столбца/строки не равен их номеру, потому что индекс начинается с 0, а номер с 1."}
    },
    "major_version": 1,
    "minor_version": 0,
    "modules": [
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "xlsx-populate",
            "ModuleVersion": "*"
        }
    ],
    "name": "Excel"
}
