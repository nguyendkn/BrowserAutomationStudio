{
    "actions": [
        {
            "code": [
                {
                    "file": "FTP_Config_code.js",
                    "name": "FTP_Config_code"
                }
            ],
            "description": {
                "en": "Configure FTP/SSH",
                "ru": "Настроить FTP/SSH"
            },
            "interface": "FTP_Config_interface.js",
            "is_element": false,
            "name": "FTP_Config",
            "select": "FTP_Config_select.js",
            "template": "{{Host}}"
        },
        {
            "code": [
                {
                    "file": "FTP_ReadFile_code.js",
                    "name": "FTP_ReadFile_code"
                }
            ],
            "description": {
                "en": "Read file",
                "ru": "Читать файл"
            },
            "interface": "FTP_ReadFile_interface.js",
            "is_element": false,
            "name": "FTP_ReadFile",
            "select": "FTP_ReadFile_select.js",
            "template": "{{FilePath}} -> {{Save}}"
        },
        {
            "code": [
                {
                    "file": "FTP_WriteFile_code.js",
                    "name": "FTP_WriteFile_code"
                }
            ],
            "description": {
                "en": "Write to file",
                "ru": "Запись в файл"
            },
            "interface": "FTP_WriteFile_interface.js",
            "is_element": false,
            "name": "FTP_WriteFile",
            "select": "FTP_WriteFile_select.js",
            "template": "{{Value}} -> {{FilePath}}"
        },
		{
            "code": [
                {
                    "file": "FTP_Download_code.js",
                    "name": "FTP_Download_code"
                }
            ],
            "description": {
                "en": "Download file/folder",
                "ru": "Скачать файл/папку"
            },
            "interface": "FTP_Download_interface.js",
            "is_element": false,
            "name": "FTP_Download",
            "select": "FTP_Download_select.js",
            "template": "{{FilePath}} -> {{DestinationPath}}"
        },
		{
            "code": [
                {
                    "file": "FTP_Upload_code.js",
                    "name": "FTP_Upload_code"
                }
            ],
            "description": {
                "en": "Upload file/folder",
                "ru": "Загрузить файл/папку"
            },
            "interface": "FTP_Upload_interface.js",
            "is_element": false,
            "name": "FTP_Upload",
            "select": "FTP_Upload_select.js",
            "template": "{{FilePath}} -> {{DestinationPath}}"
        },
        {
            "code": [
                {
                    "file": "FTP_CheckExist_code.js",
                    "name": "FTP_CheckExist_code"
                }
            ],
            "description": {
                "en": "Check file/folder exists",
                "ru": "Проверить существование файла/папки"
            },
            "interface": "FTP_CheckExist_interface.js",
            "is_element": false,
            "name": "FTP_CheckExist",
            "select": "FTP_CheckExist_select.js",
            "template": "{{FilePath}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "FTP_GetInfo_code.js",
                    "name": "FTP_GetInfo_code"
                }
            ],
            "description": {
                "en": "File/Folder info",
                "ru": "Информация о файле/папке"
            },
            "interface": "FTP_GetInfo_interface.js",
            "is_element": false,
            "name": "FTP_GetInfo",
            "select": "FTP_GetInfo_select.js",
            "template": "{{FilePath}}"
        },
        {
            "code": [
                {
                    "file": "FTP_Create_code.js",
                    "name": "FTP_Create_code"
                }
            ],
            "description": {
                "en": "Create file/folder",
                "ru": "Создать файл/папку"
            },
            "interface": "FTP_Create_interface.js",
            "is_element": false,
            "name": "FTP_Create",
            "select": "FTP_Create_select.js",
            "template": "{{FilePath}}"
        },
        {
            "code": [
                {
                    "file": "FTP_Delete_code.js",
                    "name": "FTP_Delete_code"
                }
            ],
            "description": {
                "en": "Delete file/folder",
                "ru": "Удалить файл/папку"
            },
            "interface": "FTP_Delete_interface.js",
            "is_element": false,
            "name": "FTP_Delete",
            "select": "FTP_Delete_select.js",
            "template": "{{FilePath}}"
        },
        {
            "code": [
                {
                    "file": "FTP_Move_code.js",
                    "name": "FTP_Move_code"
                }
            ],
            "description": {
                "en": "Move file/folder",
                "ru": "Переместить Файл/папку"
            },
            "interface": "FTP_Move_interface.js",
            "is_element": false,
            "name": "FTP_Move",
            "select": "FTP_Move_select.js",
            "template": "{{FilePath}} -> {{NewFilePath}}"
        },
        {
            "code": [
                {
                    "file": "FTP_Copy_code.js",
                    "name": "FTP_Copy_code"
                }
            ],
            "description": {
                "en": "Copy file/folder",
                "ru": "Копировать файл/папку"
            },
            "interface": "FTP_Copy_interface.js",
            "is_element": false,
            "name": "FTP_Copy",
            "select": "FTP_Copy_select.js",
            "template": "{{FilePath}} -> {{CopyPath}}"
        },
        {
            "code": [
                {
                    "file": "FTP_Search_code.js",
                    "name": "FTP_Search_code"
                }
            ],
            "description": {
                "en": "Search files/folders",
                "ru": "Поиск файлов/папок"
            },
            "interface": "FTP_Search_interface.js",
            "is_element": false,
            "name": "FTP_Search",
            "select": "FTP_Search_select.js",
            "template": "{{FolderPath}} -> {{Save}}"
        },
        {
            "code": [
                {
                    "file": "FTP_FileToList_code.js",
                    "name": "FTP_FileToList_code"
                }
            ],
            "description": {
                "en": "Read file to list",
                "ru": "Читать файл в список"
            },
            "interface": "FTP_FileToList_interface.js",
            "is_element": false,
            "name": "FTP_FileToList",
            "select": "FTP_FileToList_select.js",
            "template": "{{FilePath}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "FTP_ListToFile_code.js",
                    "name": "FTP_ListToFile_code"
                }
            ],
            "description": {
                "en": "Write list to file",
                "ru": "Записать список в файл"
            },
            "interface": "FTP_ListToFile_interface.js",
            "is_element": false,
            "name": "FTP_ListToFile",
            "select": "FTP_ListToFile_select.js",
            "template": "{{Value}} -> {{FilePath}}"
        },
		{
            "code": [
                {
                    "file": "FTP_RunCommand_code.js",
                    "name": "FTP_RunCommand_code"
                }
            ],
            "description": {
                "en": "Run command (SSH)",
                "ru": "Выполнить команду (SSH)"
            },
            "interface": "FTP_RunCommand_interface.js",
            "is_element": false,
            "name": "FTP_RunCommand",
            "select": "FTP_RunCommand_select.js",
            "template": "{{Command}} -> {{Standart}}"
        },
		{
            "code": [
                {
                    "file": "FTP_CalculateChecksum_code.js",
                    "name": "FTP_CalculateChecksum_code"
                }
            ],
            "description": {
                "en": "Calculate checksum (SSH)",
                "ru": "Рассчитать контрольную сумму (SSH)"
            },
            "interface": "FTP_CalculateChecksum_interface.js",
            "is_element": false,
            "name": "FTP_CalculateChecksum",
            "select": "FTP_CalculateChecksum_select.js",
            "template": "{{FilePath}} -> {{Save}}"
        },
		{
            "code": [
                {
                    "file": "FTP_Close_code.js",
                    "name": "FTP_Close_code"
                }
            ],
            "description": {
                "en": "Close connection",
                "ru": "Закрыть соединение"
            },
            "interface": "FTP_Close_interface.js",
            "is_element": false,
            "name": "FTP_Close",
            "select": "FTP_Close_select.js",
            "template": ""
        }
    ],
    "api_version": 1,
    "autogenerated_functions": [
		"FTP_ReadFile",
        "FTP_WriteFile",
        "FTP_Config",
        "FTP_CheckExist",
        "FTP_GetInfo",
        "FTP_Create",
        "FTP_Delete",
        "FTP_Move",
		"FTP_Copy",
        "FTP_Search",
        "FTP_Download",
        "FTP_Upload",
        "FTP_FileToList",
        "FTP_ListToFile",
		"FTP_RunCommand",
		"FTP_CalculateChecksum",
		"FTP_Close"
    ],
    "browser": [
    ],
    "depends": [
    ],
    "description": "Working with remote servers",
    "description_small": {
        "en": "FTP/SSH",
        "ru": "FTP/SSH"
    },
    "developer_email": "sasha9817@mail.ru",
    "developer_name": "GhostZ",
    "developer_site": "https://t.me/GhostZed",
	"embeddeddata": [
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nvar file_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar destination_directory = [[FTP_NODE_PARAMETERS]][1];\r\nvar id = [[FTP_NODE_PARAMETERS]][2];\r\nvar config = [[FTP_NODE_PARAMETERS]][3];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][4];\r\nvar file_name = path.basename(file_path);\r\nvar file_directory = path.dirname(file_path);\r\nvar destination_path = destination_directory + \"/\" + file_name;\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"FTP\", function(err, ftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = ftp.client;\r\n            function uploadFolder(dir, destination, done){\r\n                client.mkdir(destination, true, function(err){\r\n                    if(err){\r\n                        return done(err);\r\n                    }else{\r\n                        fs.readdir(dir, function(err, list){\r\n                            if(err){\r\n                                return done(err);\r\n                            }else{\r\n                                var pending = list.length;\r\n                                if(!pending){return done(null)};\r\n                                list.forEach(function(file){\r\n                                    var fileName = file;\r\n                                    var fileFullPath = dir + \"/\" + fileName;\r\n                                    var destinationDirectory = destination;\r\n                                    var destinationFullPath = destination + \"/\" + fileName;\r\n                                    fs.stat(fileFullPath, function(err, stats){\r\n                                        if(err){\r\n                                            return done(err)\r\n                                        }else{\r\n                                            if(stats && stats.isDirectory()){\r\n                                                uploadFolder(fileFullPath, destinationFullPath, function(err){\r\n                                                    if(err){\r\n                                                        return done(err);\r\n                                                    }else{\r\n                                                        BAS_PERHAPS_STOP();\r\n                                                        if(!--pending){done(null)};\r\n                                                    };\r\n                                                });\r\n                                            }else{\r\n                                                client.mkdir(destinationDirectory, true, function(err){\r\n                                                    if(err){\r\n                                                        return done(err);\r\n                                                    }else{\r\n                                                        client.put(fileFullPath, destinationFullPath, function(err){\r\n                                                            if(err){\r\n                                                                return done(err);\r\n                                                            }else{\r\n                                                                BAS_PERHAPS_STOP();\r\n                                                                if(!--pending){done(null)};\r\n                                                            };\r\n                                                        });\r\n                                                    };\r\n                                                });\r\n                                            };\r\n                                        }\r\n                                    });\r\n                                });\r\n                            };\r\n                        });\r\n                    };\r\n                });\r\n            };\r\n            \r\n            fs.exists(file_path, function(exist){\r\n                if(exist){\r\n                    fs.stat(file_path, function(err, stats){\r\n                        if(err){\r\n                            ftp.setTimeout(timeout);\r\n                            reject(err);\r\n                        }else{\r\n                            if(stats.isDirectory()){\r\n                                uploadFolder(file_path, destination_directory, function(err){\r\n                                    if(err){\r\n                                        ftp.setTimeout(timeout);\r\n                                        reject(err);\r\n                                    }else{\r\n                                        ftp.setTimeout(timeout);\r\n                                        resolve();\r\n                                    };\r\n                                });\r\n                            }else{\r\n                                client.mkdir(destination_directory, true, function(err){\r\n                                    if(err){\r\n                                        ftp.setTimeout(timeout);\r\n                                        reject(err);\r\n                                    }else{\r\n                                        client.put(file_path, destination_path, function(err){\r\n                                            if(err){\r\n                                                ftp.setTimeout(timeout);\r\n                                                reject(err);\r\n                                            }else{\r\n                                                ftp.setTimeout(timeout);\r\n                                                resolve();\r\n                                            };\r\n                                        });\r\n                                    };\r\n                                });\r\n                            };\r\n                        };\r\n                    });\r\n                }else{\r\n                    ftp.setTimeout(timeout);\r\n                    reject('The file/folder \"' + file_path + '\" does not exist');\r\n                };\r\n            });\r\n            client.on('error', function(err){\r\n                ftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n            client.on('close', function close(){\r\n                reject(\"Connection closed\");\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "UploadFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nvar file_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar destination_directory = [[FTP_NODE_PARAMETERS]][1];\r\nvar id = [[FTP_NODE_PARAMETERS]][2];\r\nvar config = [[FTP_NODE_PARAMETERS]][3];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][4];\r\nvar file_name = path.basename(file_path);\r\nvar file_directory = path.dirname(file_path);\r\nvar destination_path = destination_directory + \"/\" + file_name;\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SFTP\", function(err, sftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = sftp.client;\r\n            function ensureDirectoryExistence(filePath, done){\r\n                var dirname = path.dirname(filePath);\r\n                var exists = client.exists(dirname);\r\n                exists.then(function(exist){\r\n                    if(exist){\r\n                        done(null);\r\n                    }else{\r\n                        var mkdir = client.mkdir(dirname, true);\r\n                        mkdir.then(function(){\r\n                            done(null);\r\n                        });\r\n                        mkdir.catch(function(err){\r\n                            return done(err);\r\n                        });\r\n                    };\r\n                });\r\n                exists.catch(function(err){\r\n                    return done(err);\r\n                });\r\n            };\r\n            \r\n            function uploadFolder(dir, destination, done){\r\n                ensureDirectoryExistence(destination + \"/test.txt\", function(err){\r\n                    if(err){\r\n                        return done(err);\r\n                    }else{\r\n                        fs.readdir(dir, function(err, list){\r\n                            if(err){\r\n                                return done(err);\r\n                            }else{\r\n                                var pending = list.length;\r\n                                if(!pending){return done(null)};\r\n                                list.forEach(function(file){\r\n                                    var fileName = file;\r\n                                    var fileFullPath = dir + \"/\" + fileName;\r\n                                    var destinationDirectory = destination;\r\n                                    var destinationFullPath = destination + \"/\" + fileName;\r\n                                    fs.stat(fileFullPath, function(err, stats){\r\n                                        if(err){\r\n                                            return done(err)\r\n                                        }else{\r\n                                            if(stats && stats.isDirectory()){\r\n                                                uploadFolder(fileFullPath, destinationFullPath, function(err){\r\n                                                    if(err){\r\n                                                        return done(err);\r\n                                                    }else{\r\n                                                        BAS_PERHAPS_STOP();\r\n                                                        if(!--pending){done(null)};\r\n                                                    };\r\n                                                });\r\n                                            }else{\r\n                                                ensureDirectoryExistence(destinationDirectory + \"/test.txt\", function(err){\r\n                                                    if(err){\r\n                                                        return done(err);\r\n                                                    }else{\r\n                                                        var fastPut = client.fastPut(fileFullPath, destinationFullPath);\r\n                                                        fastPut.then(function(){\r\n                                                            BAS_PERHAPS_STOP();\r\n                                                            if(!--pending){done(null)};\r\n                                                        });\r\n                                                        fastPut.catch(function(err){\r\n                                                            return done(err);\r\n                                                        });\r\n                                                    };\r\n                                                });\r\n                                            };\r\n                                        }\r\n                                    });\r\n                                });\r\n                            };\r\n                        });\r\n                    };\r\n                });\r\n            };\r\n\r\n            fs.exists(file_path, function(exist){\r\n                if(exist){\r\n                    fs.stat(file_path, function(err, stats){\r\n                        if(err){\r\n                            sftp.setTimeout(timeout);\r\n                            reject(err);\r\n                        }else{\r\n                            ensureDirectoryExistence(destination_path, function(err){\r\n                                if(err){\r\n                                    sftp.setTimeout(timeout);\r\n                                    reject(err);\r\n                                }else{\r\n                                    if(stats.isDirectory()){\r\n                                        uploadFolder(file_path, destination_directory, function(err){\r\n                                            if(err){\r\n                                                sftp.setTimeout(timeout);\r\n                                                reject(err);\r\n                                            }else{\r\n                                                sftp.setTimeout(timeout);\r\n                                                resolve();\r\n                                            };\r\n                                        });\r\n                                    }else{\r\n                                        var fastPut = client.fastPut(file_path, destination_path);\r\n                                        fastPut.then(function(){\r\n                                            sftp.setTimeout(timeout);\r\n                                            resolve();\r\n                                        });\r\n                                        fastPut.catch(function(err){\r\n                                            sftp.setTimeout(timeout);\r\n                                            reject(err);\r\n                                        });\r\n                                    };\r\n                                };\r\n                            });\r\n                        };\r\n                    });\r\n                }else{\r\n                    sftp.setTimeout(timeout);\r\n                    reject('The file/folder \"' + file_path + '\" does not exist');\r\n                };\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "UploadSFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst utils = require(\"ssh2-sftp-client/src/utils.js\");\r\nconst targetType2 = {\"writeFile\":1, \"readFile\":2, \"writeDir\":3, \"readDir\":4, \"readObj\":5, \"writeObj\":6};\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar id = [[FTP_NODE_PARAMETERS]][1];\r\nvar config = [[FTP_NODE_PARAMETERS]][2];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][3];\r\n\r\nvar rmdir = async function(remotePath, recursive = true){\r\n    const _rmdir = (p) => {\r\n        var self = this;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            self.sftp.rmdir(p, (err) => {\r\n                if (err) {\r\n                    reject(utils.formatError(`${err.message} ${p}`, '_rmdir', err.code));\r\n                };\r\n                resolve('Successfully removed directory');\r\n            });\r\n        });\r\n    };\r\n\r\n    try{\r\n        utils.haveConnection(this, 'rmdir');\r\n        let pathInfo = await utils.checkRemotePath(this, remotePath, targetType2.writeDir);\r\n        if(!pathInfo.valid){\r\n            let e = utils.formatError(pathInfo.msg, 'rmdir', pathInfo.code);\r\n            throw e;\r\n        };\r\n        if(!recursive){\r\n            return _rmdir(pathInfo.path);\r\n        };\r\n        let list = await this.list(pathInfo.path);\r\n        if(list.length){\r\n            let files = list.filter((item) => item.type!=='d');\r\n            let dirs = list.filter((item) => item.type==='d');\r\n            for(let f of files){\r\n                await this.delete(pathInfo.path + this.remotePathSep + f.name);\r\n                BAS_PERHAPS_STOP();\r\n            };\r\n            for(let d of dirs){\r\n                await this.rmdir(pathInfo.path + this.remotePathSep + d.name, true);\r\n                BAS_PERHAPS_STOP();\r\n            };\r\n        };\r\n        return _rmdir(pathInfo.path);\r\n    }catch(err){\r\n        throw utils.formatError(err, 'rmdir');\r\n    };\r\n};\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SFTP\", function(err, sftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = sftp.client;\r\n            client.rmdir = rmdir;\r\n            var exists = client.exists(remote_path);\r\n            exists.then(function(exist){\r\n                if(exist){\r\n                    var stat = client.stat(remote_path);\r\n                    stat.then(function(stats){\r\n                        var isDirectory = stats.isDirectory;\r\n                        if(isDirectory){\r\n                            var rmdir = client.rmdir(remote_path, true);\r\n                            rmdir.then(function(){\r\n                                sftp.setTimeout(timeout);\r\n                                resolve();\r\n                            });\r\n                            rmdir.catch(function(err){\r\n                                sftp.setTimeout(timeout);\r\n                                reject(err);\r\n                            });\r\n                        }else{\r\n                            var deletef = client.delete(remote_path);\r\n                            deletef.then(function(){\r\n                                sftp.setTimeout(timeout);\r\n                                resolve();\r\n                            });\r\n                            deletef.catch(function(err){\r\n                                sftp.setTimeout(timeout);\r\n                                reject(err);\r\n                            });\r\n                        };\r\n                    });\r\n                    stat.catch(function(err){\r\n                        sftp.setTimeout(timeout);\r\n                        reject(err);\r\n                    });\r\n                }else{\r\n                    sftp.setTimeout(timeout);\r\n                    resolve();\r\n                };\r\n            });\r\n            exists.catch(function(err){\r\n                sftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "DeleteSFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar id = [[FTP_NODE_PARAMETERS]][1];\r\nvar config = [[FTP_NODE_PARAMETERS]][2];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][3];\r\nvar remote_name = path.basename(remote_path);\r\nvar remote_directory = path.dirname(remote_path);\r\n\r\nvar rmdir = function(path, recursive, cb){\r\n    if(typeof recursive==='function'){\r\n        cb = recursive;\r\n        recursive = false;\r\n    };\r\n    if(!recursive){\r\n        return this._send('RMD ' + path, cb);\r\n    };\r\n\r\n    var self = this;\r\n    this.list(path, function(err, list){\r\n        if(err){\r\n\t\t\treturn cb(err);\r\n\t\t};\r\n        var idx = 0;\r\n\t\t\r\n        var deleteNextEntry;\r\n        deleteNextEntry = function(err){\r\n            if(err){\r\n                return cb(err);\r\n\t\t\t};\r\n            if(idx>=list.length) {\r\n                if(list[0] && decodeName(list[0].name)===path){\r\n                    return cb(null);\r\n                }else{\r\n                    return self.rmdir(path, cb);\r\n                };\r\n            };\r\n\r\n            var entry = list[idx++];\r\n\t\t\t\r\n            var subpath = null;\r\n            if(entry.name[0]==='/'){\r\n                subpath = decodeName(entry.name);\r\n            }else{\r\n                if(path[path.length - 1]=='/'){\r\n                    subpath = path + decodeName(entry.name);\r\n                }else{\r\n                    subpath = path + '/' + decodeName(entry.name);\r\n                };\r\n            };\r\n\r\n            if(entry.type==='d'){\r\n                if(entry.name===\".\" || entry.name===\"..\"){\r\n                    return deleteNextEntry();\r\n                };\r\n                self.rmdir(subpath, true, deleteNextEntry);\r\n                BAS_PERHAPS_STOP();\r\n            } else {\r\n                self.delete(subpath, deleteNextEntry);\r\n                BAS_PERHAPS_STOP();\r\n            };\r\n        };\r\n        deleteNextEntry();\r\n    });\r\n};\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"FTP\", function(err, ftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = ftp.client;\r\n            client.rmdir = rmdir;\r\n            client.list(remote_directory, function(err, list){\r\n                if(err){\r\n                    ftp.setTimeout(timeout);\r\n                    reject(err);\r\n                }else{\r\n                    var list = list.filter(function(file){return decodeName(file[\"name\"])==remote_name});\r\n                    if(list.length > 0){\r\n                        if(list[0][\"type\"]==\"d\"){\r\n                            client.rmdir(remote_path, true, function(err){\r\n                                if(err){\r\n                                    ftp.setTimeout(timeout);\r\n                                    reject(err);\r\n                                }else{\r\n                                    ftp.setTimeout(timeout);\r\n                                    resolve();\r\n                                };\r\n                            });\r\n                        }else{\r\n                            client.delete(remote_path, function(err){\r\n                                if(err){\r\n                                    ftp.setTimeout(timeout);\r\n                                    reject(err);\r\n                                }else{\r\n                                    ftp.setTimeout(timeout);\r\n                                    resolve();\r\n                                };\r\n                            });\r\n                        };\r\n                    }else{\r\n                        ftp.setTimeout(timeout);\r\n                        resolve();\r\n                    };\r\n                };\r\n            });\r\n            client.on('error', function(err){\r\n                ftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n            client.on('close', function close(){\r\n                reject(\"Connection closed\");\r\n            });\r\n        };\r\n    });\r\n}));\r\n\r\nfunction decodeName(name){\r\n    return decodeURIComponent(escape(name));\r\n};",
            "DataName": "DeleteFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar new_remote_path = [[FTP_NODE_PARAMETERS]][1];\r\nvar id = [[FTP_NODE_PARAMETERS]][2];\r\nvar config = [[FTP_NODE_PARAMETERS]][3];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][4];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SFTP\", function(err, sftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = sftp.client;\r\n            function ensureDirectoryExistence(filePath, done){\r\n                var dirname = path.dirname(filePath);\r\n                var exists = client.exists(dirname);\r\n                exists.then(function(exist){\r\n                    if(exist){\r\n                        done(null);\r\n                    }else{\r\n                        var mkdir = client.mkdir(dirname, true);\r\n                        mkdir.then(function(){\r\n                            done(null);\r\n                        });\r\n                        mkdir.catch(function(err){\r\n                            done(err);\r\n                        });\r\n                    };\r\n                });\r\n                exists.catch(function(err){\r\n                    done(err);\r\n                });\r\n            };\r\n            \r\n            var exists = client.exists(remote_path);\r\n            exists.then(function(exist){\r\n                if(exist){\r\n                    ensureDirectoryExistence(new_remote_path, function(err){\r\n                        if(err){\r\n                            sftp.setTimeout(timeout);\r\n                            reject(err);\r\n                        }else{\r\n                            var rename = client.rename(remote_path, new_remote_path);\r\n                            rename.then(function(){\r\n                                sftp.setTimeout(timeout);\r\n                                resolve();\r\n                            });\r\n                            rename.catch(function(err){\r\n                                sftp.setTimeout(timeout);\r\n                                reject(err);\r\n                            });\r\n                        };\r\n                    });\r\n                }else{\r\n                    sftp.setTimeout(timeout);\r\n                    reject('The file \"' + remote_path + '\" does not exist');\r\n                };\r\n            });\r\n            exists.catch(function(err){\r\n                sftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "MoveSFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar new_remote_path = [[FTP_NODE_PARAMETERS]][1];\r\nvar id = [[FTP_NODE_PARAMETERS]][2];\r\nvar config = [[FTP_NODE_PARAMETERS]][3];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][4];\r\nvar remote_name = path.basename(remote_path);\r\nvar remote_directory = path.dirname(remote_path);\r\nvar new_remote_directory = path.dirname(new_remote_path);\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"FTP\", function(err, ftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = ftp.client;\r\n            client.list(remote_directory, function(err, list){\r\n                if(err){\r\n                    ftp.setTimeout(timeout);\r\n                    reject(err);\r\n                }else{\r\n                    var list = list.filter(function(file){return decodeURIComponent(escape(file[\"name\"]))==remote_name});\r\n                    if(list.length > 0){\r\n                        client.mkdir(new_remote_directory, true, function(err){\r\n                            if(err){\r\n                                ftp.setTimeout(timeout);\r\n                                reject(err);\r\n                            }else{\r\n                                client.rename(remote_path, new_remote_path, function(err){\r\n                                    if(err){\r\n                                        ftp.setTimeout(timeout);\r\n                                        reject(err);\r\n                                    }else{\r\n                                        ftp.setTimeout(timeout);\r\n                                        resolve();\r\n                                    };\r\n                                });\r\n                            };\r\n                        });\r\n                    }else{\r\n                        ftp.setTimeout(timeout);\r\n                        reject('The file/folder \"' + remote_path + '\" does not exist');\r\n                    };\r\n                };\r\n            });\r\n            client.on('error', function(err){\r\n                ftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n            client.on('close', function close(){\r\n                reject(\"Connection closed\");\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "MoveFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar id = [[FTP_NODE_PARAMETERS]][1];\r\nvar config = [[FTP_NODE_PARAMETERS]][2];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][3];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SFTP\", function(err, sftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = sftp.client;\r\n            var exists = client.exists(remote_path);\r\n            exists.then(function(exist){\r\n                [[FTP_NODE_PARAMETERS]] = exist ? true : false;\r\n                sftp.setTimeout(timeout);\r\n                resolve();\r\n            });\r\n            exists.catch(function(err){\r\n                sftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "CheckExistSFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar id = [[FTP_NODE_PARAMETERS]][1];\r\nvar config = [[FTP_NODE_PARAMETERS]][2];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][3];\r\nvar remote_name = path.basename(remote_path);\r\nvar remote_directory = path.dirname(remote_path);\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"FTP\", function(err, ftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = ftp.client;\r\n            client.list(remote_directory, function(err, list){\r\n                if(err){\r\n                    if(err.message.indexOf(\"No such file or directory\") > -1){\r\n                        [[FTP_NODE_PARAMETERS]] = false;\r\n                        ftp.setTimeout(timeout);\r\n                        resolve();\r\n                    }else{\r\n                        ftp.setTimeout(timeout);\r\n                        reject(err);\r\n                    };\r\n                }else{\r\n                    if(list.filter(function(file){return decodeURIComponent(escape(file[\"name\"]))==remote_name}).length > 0){\r\n                        [[FTP_NODE_PARAMETERS]] = true;\r\n                    }else{\r\n                        [[FTP_NODE_PARAMETERS]] = false;\r\n                    };\r\n                    ftp.setTimeout(timeout);\r\n                    resolve();\r\n                };\r\n            });\r\n            client.on('error', function(err){\r\n                ftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n            client.on('close', function close(){\r\n                reject(\"Connection closed\");\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "CheckExistFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar id = [[FTP_NODE_PARAMETERS]][1];\r\nvar config = [[FTP_NODE_PARAMETERS]][2];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][3];\r\nvar remote_directory = path.dirname(remote_path);\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SFTP\", function(err, sftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = sftp.client;\r\n            var exists = client.exists(remote_path);\r\n            exists.then(function(exist){\r\n                if(exist){\r\n                    var stat = client.stat(remote_path);\r\n                    stat.then(function(stats){\r\n                        [[FTP_NODE_PARAMETERS]] = {directory: remote_directory, exists: true, is_directory: stats.isDirectory, is_file: stats.isFile, last_modified: stats.modifyTime, size: stats.size};\r\n                        sftp.setTimeout(timeout);\r\n                        resolve();\r\n                    });\r\n                    stat.catch(function(err){\r\n                        sftp.setTimeout(timeout);\r\n                        reject(err);\r\n                    });\r\n                }else{\r\n                    [[FTP_NODE_PARAMETERS]] = {directory: \"\", exists: false, is_directory: false, is_file: false, last_modified: 0, size: 0};\r\n                    sftp.setTimeout(timeout);\r\n                    resolve();\r\n                };\r\n            });\r\n            exists.catch(function(err){\r\n                sftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "GetInfoSFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar id = [[FTP_NODE_PARAMETERS]][1];\r\nvar config = [[FTP_NODE_PARAMETERS]][2];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][3];\r\nvar remote_name = path.basename(remote_path);\r\nvar remote_directory = path.dirname(remote_path);\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"FTP\", function(err, ftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = ftp.client;\r\n            client.list(remote_directory, function(err, list){\r\n                if(err){\r\n                    if(err.message.indexOf(\"No such file or directory\") > -1){\r\n                        [[FTP_NODE_PARAMETERS]] = {directory: \"\", exists: false, is_directory: false, is_file: false, last_modified: 0, size: 0};\r\n                        ftp.setTimeout(timeout);\r\n                        resolve();\r\n                    }else{\r\n                        ftp.setTimeout(timeout);\r\n                        reject(err);\r\n                    };\r\n                }else{\r\n                    var list = list.filter(function(file){return decodeURIComponent(escape(file[\"name\"]))==remote_name});\r\n                    if(list.length > 0){\r\n                        var file = list[0];\r\n                        var type = file[\"type\"];\r\n                        var last_modified = new Date(file[\"date\"]).getTime();\r\n                        var size = file[\"size\"];\r\n                        [[FTP_NODE_PARAMETERS]] = {directory: remote_directory, exists: true, is_directory: (type==\"d\" ? true : false), is_file: (type==\"-\" ? true : false), last_modified: last_modified, size: size};\r\n                    }else{\r\n                        [[FTP_NODE_PARAMETERS]] = {directory: \"\", exists: false, is_directory: false, is_file: false, last_modified: 0, size: 0};\r\n                    };\r\n                    ftp.setTimeout(timeout);\r\n                    resolve();\r\n                };\r\n            });\r\n            client.on('error', function(err){\r\n                ftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n            client.on('close', function close(){\r\n                reject(\"Connection closed\");\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "GetInfoFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar destination_directory = [[FTP_NODE_PARAMETERS]][1];\r\nvar id = [[FTP_NODE_PARAMETERS]][2];\r\nvar config = [[FTP_NODE_PARAMETERS]][3];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][4];\r\nvar remote_name = path.basename(remote_path);\r\nvar remote_directory = path.dirname(remote_path);\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"FTP\", function(err, ftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = ftp.client;\r\n            function downloadFile(remote, destination){\r\n                client.get(remote, function(err, stream){\r\n                    if(err){\r\n                        ftp.setTimeout(timeout);\r\n                        reject(err);\r\n                    }else{\r\n                        ensureDirectoryExistence(destination);\r\n                        var writeStream = stream.pipe(fs.createWriteStream(destination));\r\n                        writeStream.on('error', function(err){\r\n                            ftp.setTimeout(timeout);\r\n                            reject(err);\r\n                        });\r\n                        writeStream.on('close', function close(){\r\n                            ftp.setTimeout(timeout);\r\n                            resolve();\r\n                        });\r\n                    };\r\n                });\r\n            };\r\n            \r\n            function downloadFolder(remote, destination, done){\r\n                ensureDirectoryExistence(destination + \"/test.txt\");\r\n                client.list(remote, function(err, list){\r\n                    if(err){\r\n                        return done(err);\r\n                    }else{\r\n                        var list = list.filter(function(file){return [\".\",\"..\"].indexOf(file[\"name\"]) < 0});\r\n                        var pending = list.length;\r\n                        if(!pending){return done(null)};\r\n                        list.forEach(function(file){\r\n                            var fileName = decodeName(file[\"name\"]);\r\n                            var fileType = file[\"type\"];\r\n                            var remoteFullPath = remote + \"/\" + fileName;\r\n                            var destinationFullPath = destination + \"/\" + fileName;\r\n                            if(fileType==\"d\"){\r\n                                downloadFolder(remoteFullPath, destinationFullPath, function(err){\r\n                                    if(err){\r\n                                        return done(err);\r\n                                    }else{\r\n                                        BAS_PERHAPS_STOP();\r\n                                        if(!--pending){done(null)};\r\n                                    };\r\n                                });\r\n                            }else{\r\n                                client.get(remoteFullPath, function(err, stream){\r\n                                    if(err){\r\n                                        return done(err);\r\n                                    }else{\r\n                                        var writeStream = stream.pipe(fs.createWriteStream(destinationFullPath));\r\n                                        writeStream.on('error', function(err){\r\n                                            return done(err);\r\n                                        });\r\n                                        writeStream.on('close', function close(){\r\n                                            BAS_PERHAPS_STOP();\r\n                                            if(!--pending){done(null)};\r\n                                        });\r\n                                    };\r\n                                });\r\n                            };\r\n                        });\r\n                    };\r\n                });\r\n            };\r\n\r\n            client.list(remote_directory, function(err, list){\r\n                if(err){\r\n                    ftp.setTimeout(timeout);\r\n                    reject(err);\r\n                }else{\r\n                    var list = list.filter(function(file){return decodeName(file[\"name\"])==remote_name});\r\n                    if(list.length > 0){\r\n                        var file = list[0];\r\n                        var fileName = decodeName(file[\"name\"]);\r\n                        var fileType = file[\"type\"];\r\n                        var destination_path = destination_directory + \"/\" + fileName;\r\n                        if(fileType!=\"d\" && fs.existsSync(destination_directory)){\r\n                            fs.stat(destination_directory, function(err, stats){\r\n                                if(err){\r\n                                    ftp.setTimeout(timeout);\r\n                                    reject(err);\r\n                                }else{\r\n                                    if(stats.isDirectory()){\r\n                                        downloadFile(remote_path, destination_path);\r\n                                    }else{\r\n                                        downloadFile(remote_path, destination_directory);\r\n                                    }\r\n                                };\r\n                            });\r\n                        }else{\r\n                            ensureDirectoryExistence(destination_path);\r\n                            if(fileType==\"d\"){\r\n                                downloadFolder(remote_path, destination_directory, function(err){\r\n                                    if(err){\r\n                                        ftp.setTimeout(timeout);\r\n                                        reject(err);\r\n                                    }else{\r\n                                        ftp.setTimeout(timeout);\r\n                                        resolve();\r\n                                    };\r\n                                });\r\n                            }else{\r\n                                downloadFile(remote_path, destination_path);\r\n                            };\r\n                        };\r\n                    }else{\r\n                        ftp.setTimeout(timeout);\r\n                        reject('The file/folder \"' + remote_path + '\" does not exist');\r\n                    };\r\n                };\r\n            });\r\n            client.on('error', function(err){\r\n                ftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n            client.on('close', function close(){\r\n                reject(\"Connection closed\");\r\n            });\r\n        };\r\n    });\r\n}));\r\n\r\nfunction decodeName(name) {\r\n    return decodeURIComponent(escape(name))\r\n};\r\n\r\nfunction ensureDirectoryExistence(filePath) {\r\n    var dirname = path.dirname(filePath);\r\n    if(fs.existsSync(dirname)){\r\n        return true;\r\n    };\r\n    ensureDirectoryExistence(dirname);\r\n    fs.mkdirSync(dirname);\r\n};",
            "DataName": "DownloadFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar folder_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar masks = [[FTP_NODE_PARAMETERS]][1];\r\nvar recursive = [[FTP_NODE_PARAMETERS]][2];\r\nvar search_files = [[FTP_NODE_PARAMETERS]][3];\r\nvar search_folders = [[FTP_NODE_PARAMETERS]][4];\r\nvar id = [[FTP_NODE_PARAMETERS]][5];\r\nvar config = [[FTP_NODE_PARAMETERS]][6];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][7];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SFTP\", function(err, sftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = sftp.client;\r\n            function walk(dir, recursive, search_files, search_folders, done){\r\n                var results = [];\r\n                var list = client.list(dir);\r\n                list.then(function(list){\r\n                    var pending = list.length;\r\n                    if(!pending){return done(null, results)};\r\n                    list.forEach(function(file){\r\n                        var file_name = file.name;\r\n                        var file_type = file.type;\r\n                        var file = dir + \"/\" + file_name;\r\n                        if(file_type==\"d\"){\r\n                            search_folders ? results.push(file) : \"\";\r\n                            BAS_PERHAPS_STOP();\r\n                            if(recursive){\r\n                                walk(file, recursive, search_files, search_folders, function(err, res){\r\n                                    if(err){return done(err)};\r\n                                    results = results.concat(res);\r\n                                    BAS_PERHAPS_STOP();\r\n                                    if(!--pending){done(null, results)};\r\n                                });\r\n                            }else{\r\n                                BAS_PERHAPS_STOP();\r\n                                if(!--pending){done(null, results)};\r\n                            };\r\n                        };\r\n                        if(file_type==\"-\"){\r\n                            search_files ? results.push(file) : \"\";\r\n                            BAS_PERHAPS_STOP();\r\n                            if(!--pending){done(null, results)};\r\n                        };\r\n                    });\r\n                });\r\n                list.catch(function(err){\r\n                    done(err);\r\n                });\r\n            };\r\n\r\n            var exists = client.exists(folder_path);\r\n            exists.then(function(exist){\r\n                if(exist){\r\n                    walk(folder_path, recursive, search_files, search_folders, function(err, res){\r\n                        if(err){\r\n                            sftp.setTimeout(timeout);\r\n                            reject(err);\r\n                        }else{\r\n                            var all_filtered = [];\r\n                            masks.split(\";\").forEach(function(mask){\r\n                                var regex = new RegExp(mask.replace(/\\*([^*])*?/gi, '.*'));\r\n                                var filtered = res.filter(function(file){return regex.test(path.basename(file))});\r\n                                all_filtered = all_filtered.concat(filtered);\r\n                            });\r\n                            [[FTP_NODE_PARAMETERS]] = all_filtered;\r\n                            sftp.setTimeout(timeout);\r\n                            resolve();\r\n                        };\r\n                    });\r\n                }else{\r\n                    [[FTP_NODE_PARAMETERS]] = [];\r\n                    sftp.setTimeout(timeout);\r\n                    resolve();\r\n                };\r\n            });\r\n            exists.catch(function(err){\r\n                sftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "SearchSFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar folder_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar masks = [[FTP_NODE_PARAMETERS]][1];\r\nvar recursive = [[FTP_NODE_PARAMETERS]][2];\r\nvar search_files = [[FTP_NODE_PARAMETERS]][3];\r\nvar search_folders = [[FTP_NODE_PARAMETERS]][4];\r\nvar id = [[FTP_NODE_PARAMETERS]][5];\r\nvar config = [[FTP_NODE_PARAMETERS]][6];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][7];\r\nvar folder_name = path.basename(folder_path);\r\nvar folder_directory = path.dirname(folder_path);\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"FTP\", function(err, ftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = ftp.client;\r\n            function walk(dir, recursive, search_files, search_folders, done){\r\n                var results = [];\r\n                client.list(dir, function(err, list){\r\n                    if(err){\r\n                        done(err);\r\n                    }else{\r\n                        var list = list.filter(function(file){return [\".\",\"..\"].indexOf(file[\"name\"]) < 0});\r\n                        var pending = list.length;\r\n                        if(!pending){return done(null, results)};\r\n                        list.forEach(function(file){\r\n                            var file_name = decodeURIComponent(escape(file.name));\r\n                            var file_type = file.type;\r\n                            var file = dir + \"/\" + file_name;\r\n                            if(file_type==\"d\"){\r\n                                search_folders ? results.push(file) : \"\";\r\n                                BAS_PERHAPS_STOP();\r\n                                if(recursive){\r\n                                    walk(file, recursive, search_files, search_folders, function(err, res){\r\n                                        if(err){return done(err)};\r\n                                        results = results.concat(res);\r\n                                        BAS_PERHAPS_STOP();\r\n                                        if(!--pending){done(null, results)};\r\n                                    });\r\n                                }else{\r\n                                    BAS_PERHAPS_STOP();\r\n                                    if(!--pending){done(null, results)};\r\n                                };\r\n                            };\r\n                            if(file_type==\"-\"){\r\n                                search_files ? results.push(file) : \"\";\r\n                                BAS_PERHAPS_STOP();\r\n                                if(!--pending){done(null, results)};\r\n                            };\r\n                        });\r\n                    };\r\n                });\r\n            };\r\n            \r\n            client.list(folder_directory, function(err, list){\r\n                if(err){\r\n                    ftp.setTimeout(timeout);\r\n                    reject(err);\r\n                }else{\r\n                    var list = list.filter(function(file){return decodeURIComponent(escape(file[\"name\"]))==folder_name});\r\n                    if(list.length > 0){\r\n                        walk(folder_path, recursive, search_files, search_folders, function(err, res){\r\n                            if(err){\r\n                                ftp.setTimeout(timeout);\r\n                                reject(err);\r\n                            }else{\r\n                                var all_filtered = [];\r\n                                masks.split(\";\").forEach(function(mask){\r\n                                    var regex = new RegExp(mask.replace(/\\*([^*])*?/gi, '.*'));\r\n                                    var filtered = res.filter(function(file){return regex.test(path.basename(file))});\r\n                                    all_filtered = all_filtered.concat(filtered);\r\n                                });\r\n                                [[FTP_NODE_PARAMETERS]] = all_filtered;\r\n                                ftp.setTimeout(timeout);\r\n                                resolve();\r\n                            };\r\n                        });\r\n                    }else{\r\n                        [[FTP_NODE_PARAMETERS]] = [];\r\n                        ftp.setTimeout(timeout);\r\n                        resolve();\r\n                    };\r\n                };\r\n            });\r\n            client.on('error', function(err){\r\n                ftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n            client.on('close', function close(){\r\n                reject(\"Connection closed\");\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "SearchFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar value = [[FTP_NODE_PARAMETERS]][1];\r\nvar ending_symbol = [[FTP_NODE_PARAMETERS]][2];\r\nvar base64 = [[FTP_NODE_PARAMETERS]][3];\r\nvar append = [[FTP_NODE_PARAMETERS]][4];\r\nvar id = [[FTP_NODE_PARAMETERS]][5];\r\nvar config = [[FTP_NODE_PARAMETERS]][6];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][7];\r\nvar encoding = base64 ? 'base64' : 'utf8';\r\nvar buf = Buffer.from(value, encoding);\r\nif(ending_symbol){\r\n    var buf2 = Buffer.from('\\r\\n', 'utf8');\r\n    buf = Buffer.concat([buf, buf2]);\r\n};\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SFTP\", function(err, sftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = sftp.client;\r\n            function ensureDirectoryExistence(filePath, done){\r\n                var dirname = path.dirname(filePath);\r\n                var exists = client.exists(dirname);\r\n                exists.then(function(exist){\r\n                    if(exist){\r\n                        done(null);\r\n                    }else{\r\n                        var mkdir = client.mkdir(dirname, true);\r\n                        mkdir.then(function(){\r\n                            done(null);\r\n                        });\r\n                        mkdir.catch(function(err){\r\n                            done(err);\r\n                        });\r\n                    };\r\n                });\r\n                exists.catch(function(err){\r\n                    done(err);\r\n                });\r\n            };\r\n\r\n            ensureDirectoryExistence(remote_path, function(err){\r\n                if(err){\r\n                    sftp.setTimeout(timeout);\r\n                    reject(err);\r\n                }else{\r\n                    var exists = client.exists(remote_path);\r\n                    exists.then(function(exist){\r\n                        if(exist && append){\r\n                            var appendf = client.append(buf, remote_path);\r\n                            appendf.then(function(){\r\n                                sftp.setTimeout(timeout);\r\n                                resolve();\r\n                            });\r\n                            appendf.catch(function(err){\r\n                                sftp.setTimeout(timeout);\r\n                                reject(err);\r\n                            });\r\n                        }else{\r\n                            var putf = client.put(buf, remote_path);\r\n                            putf.then(function(){\r\n                                sftp.setTimeout(timeout);\r\n                                resolve();\r\n                            });\r\n                            putf.catch(function(err){\r\n                                sftp.setTimeout(timeout);\r\n                                reject(err);\r\n                            });\r\n                        };\r\n                    });\r\n                    exists.catch(function(err){\r\n                        sftp.setTimeout(timeout);\r\n                        reject(err);\r\n                    });\r\n                };\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "WriteFileSFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar value = [[FTP_NODE_PARAMETERS]][1];\r\nvar ending_symbol = [[FTP_NODE_PARAMETERS]][2];\r\nvar base64 = [[FTP_NODE_PARAMETERS]][3];\r\nvar append = [[FTP_NODE_PARAMETERS]][4];\r\nvar id = [[FTP_NODE_PARAMETERS]][5];\r\nvar config = [[FTP_NODE_PARAMETERS]][6];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][7];\r\nvar encoding = base64 ? 'base64' : 'utf8';\r\nvar buf = Buffer.from(value, encoding);\r\nif(ending_symbol){\r\n    var buf2 = Buffer.from('\\r\\n', 'utf8');\r\n    buf = Buffer.concat([buf, buf2]);\r\n};\r\nvar remote_directory = path.dirname(remote_path);\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"FTP\", function(err, ftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = ftp.client;\r\n            client.mkdir(remote_directory, true, function(err){\r\n                if(err){\r\n                    ftp.setTimeout(timeout);\r\n                    reject(err);\r\n                }else{\r\n                    if(append){\r\n                        client.append(buf, remote_path, function(err){\r\n                            if(err){\r\n                                ftp.setTimeout(timeout);\r\n                                reject(err);\r\n                            }else{\r\n                                ftp.setTimeout(timeout);\r\n                                resolve();\r\n                            };\r\n                        });\r\n                    }else{\r\n                        client.put(buf, remote_path, function(err){\r\n                            if(err){\r\n                                ftp.setTimeout(timeout);\r\n                                reject(err);\r\n                            }else{\r\n                                ftp.setTimeout(timeout);\r\n                                resolve();\r\n                            };\r\n                        });\r\n                    };\r\n                };\r\n            });\r\n            client.on('error', function(err){\r\n                ftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n            client.on('close', function close(){\r\n                reject(\"Connection closed\");\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "WriteFileFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "var id = [[FTP_NODE_PARAMETERS]];\r\n\r\nif(typeof ftp_connections!=\"undefined\" || typeof ftp_connections[id]!=\"undefined\"){\r\n    if(typeof ftp_connections[id].sftp!=\"undefined\" && typeof ftp_connections[id].sftp.client.sftp!=\"undefined\"){\r\n        ftp_connections[id].sftp.close(id);\r\n    };\r\n    \r\n    if(typeof ftp_connections[id].ftp!=\"undefined\"){\r\n        ftp_connections[id].ftp.close(id);\r\n    };\r\n\r\n    if(typeof ftp_connections[id].ssh!=\"undefined\"){\r\n        ftp_connections[id].ssh.close(id);\r\n    };\r\n};",
            "DataName": "CloseFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar copy_directory = [[FTP_NODE_PARAMETERS]][1];\r\nvar id = [[FTP_NODE_PARAMETERS]][2];\r\nvar config = [[FTP_NODE_PARAMETERS]][3];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][4];\r\nvar remote_name = path.basename(remote_path);\r\nvar remote_directory = path.dirname(remote_path);\r\nvar copy_path = copy_directory + \"/\" + remote_name;\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SFTP\", function(err, sftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = sftp.client;\r\n            function ensureDirectoryExistence(filePath, done){\r\n                var dirname = path.dirname(filePath);\r\n                var exists = client.exists(dirname);\r\n                exists.then(function(exist){\r\n                    if(exist){\r\n                        done(null);\r\n                    }else{\r\n                        var mkdird = client.mkdir(dirname, true);\r\n                        mkdird.then(function(){\r\n                            done(null);\r\n                        });\r\n                        mkdird.catch(function(err){\r\n                            return done(err);\r\n                        });\r\n                    };\r\n                });\r\n                exists.catch(function(err){\r\n                    return done(err);\r\n                });\r\n            };\r\n\r\n            function сopyFolder(dir, destination, done){\r\n                ensureDirectoryExistence(destination + \"/test.txt\", function(err){\r\n                    if(err){\r\n                        return done(err);\r\n                    }else{\r\n                        var list = client.list(dir);\r\n                        list.then(function(list){\r\n                            var pending = list.length;\r\n                            if(!pending){done(null)};\r\n                            list.forEach(function(file){\r\n                                var fileName = file.name;\r\n                                var fileFullPath = dir + \"/\" + fileName;\r\n                                var destinationDirectory = destination;\r\n                                var destinationFullPath = destination + \"/\" + fileName;\r\n                                var fileType = file.type;\r\n                                if(fileType==\"d\"){\r\n                                    сopyFolder(fileFullPath, destinationFullPath, function(err){\r\n                                        if(err){\r\n                                            return done(err);\r\n                                        }else{\r\n                                            BAS_PERHAPS_STOP();\r\n                                            if(!--pending){done(null)};\r\n                                        };\r\n                                    });\r\n                                };\r\n                                if(fileType==\"-\"){\r\n                                    ensureDirectoryExistence(destinationFullPath, function(err){\r\n                                        if(err){\r\n                                            return done(err);\r\n                                        }else{\r\n                                            var getf = client.get(fileFullPath);\r\n                                            getf.then(function(data){\r\n                                                data = data.toString('utf8')==\"\" ? Buffer.from('', 'utf8') : data;\r\n                                                var putf = client.put(data, destinationFullPath);\r\n                                                putf.then(function(){\r\n                                                    BAS_PERHAPS_STOP();\r\n                                                    if(!--pending){done(null)};\r\n                                                });\r\n                                                putf.catch(function(err){\r\n                                                    return done(err);\r\n                                                });\r\n                                            });\r\n                                            getf.catch(function(err){\r\n                                                return done(err);\r\n                                            });\r\n                                        };\r\n                                    });\r\n                                };\r\n                            });\r\n                        });\r\n                        list.catch(function(err){\r\n                            return done(err);\r\n                        });\r\n                    };\r\n                });\r\n            };\r\n\r\n            var exists = client.exists(remote_path);\r\n            exists.then(function(exist){\r\n                if(exist){\r\n                    var stat = client.stat(remote_path);\r\n                    stat.then(function(stats){\r\n                        if(stats.isDirectory){\r\n                            сopyFolder(remote_path, copy_directory, function(err){\r\n                                if(err){\r\n                                    sftp.setTimeout(timeout);\r\n                                    reject(err);\r\n                                }else{\r\n                                    sftp.setTimeout(timeout);\r\n                                    resolve();\r\n                                };\r\n                            });\r\n                        }else{\r\n                            ensureDirectoryExistence(copy_path, function(err){\r\n                                if(err){\r\n                                    sftp.setTimeout(timeout);\r\n                                    reject(err);\r\n                                }else{\r\n                                    var getf = client.get(remote_path);\r\n                                    getf.then(function(data){\r\n                                        var putf = client.put(data, copy_path);\r\n                                        putf.then(function(){\r\n                                            sftp.setTimeout(timeout);\r\n                                            resolve();\r\n                                        });\r\n                                        putf.catch(function(err){\r\n                                            sftp.setTimeout(timeout);\r\n                                            reject(err);\r\n                                        });\r\n                                    });\r\n                                    getf.catch(function(err){\r\n                                        sftp.setTimeout(timeout);\r\n                                        reject(err);\r\n                                    });\r\n                                };\r\n                            });\r\n                        };\r\n                    });\r\n                    stat.catch(function(err){\r\n                        sftp.setTimeout(timeout);\r\n                        reject(err);\r\n                    });\r\n                }else{\r\n                    sftp.setTimeout(timeout);\r\n                    reject('The file/folder \"' + remote_path + '\" does not exist');\r\n                };\r\n            });\r\n            exists.catch(function(err){\r\n                sftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "CopySFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar copy_directory = [[FTP_NODE_PARAMETERS]][1];\r\nvar id = [[FTP_NODE_PARAMETERS]][2];\r\nvar config = [[FTP_NODE_PARAMETERS]][3];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][4];\r\nvar ftp = ftp_connections[id].ftp;\r\nvar client = ftp.client;\r\nvar remote_name = path.basename(remote_path);\r\nvar remote_directory = path.dirname(remote_path);\r\nvar copy_path = copy_directory + \"/\" + remote_name;\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"FTP\", function(err, ftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = ftp.client;\r\n            function сopyFolder(dir, destination, done){\r\n                client.mkdir(destination, true, function(err){\r\n                    if(err){\r\n                        return done(err);\r\n                    }else{\r\n                        client.list(dir, function(err, list){\r\n                            if(err){\r\n                                return done(err);\r\n                            }else{\r\n                                var list = list.filter(function(file){return [\".\",\"..\"].indexOf(file[\"name\"]) < 0});\r\n                                var pending = list.length;\r\n                                if(!pending){return done(null)};\r\n                                list.forEach(function(file){\r\n                                    var fileName = decodeName(file.name);\r\n                                    var fileFullPath = dir + \"/\" + fileName;\r\n                                    var destinationDirectory = destination;\r\n                                    var destinationFullPath = destination + \"/\" + fileName;\r\n                                    var fileType = file.type;\r\n                                    if(fileType==\"d\"){\r\n                                        сopyFolder(fileFullPath, destinationFullPath, function(err){\r\n                                            if(err){\r\n                                                return done(err);\r\n                                            }else{\r\n                                                BAS_PERHAPS_STOP();\r\n                                                if(!--pending){done(null)};\r\n                                            };\r\n                                        });\r\n                                    };\r\n                                    if(fileType==\"-\"){\r\n                                        var chunks = [];\r\n                                        client.get(fileFullPath, function(err, stream){\r\n                                            if(err){\r\n                                                return done(err);\r\n                                            }else{\r\n                                                stream.on('data', function(chunk){\r\n                                                    chunks.push(chunk);\r\n                                                });\r\n                                                stream.on('error', function(err){\r\n                                                    return done(err);\r\n                                                });\r\n                                                stream.on('end', function(){\r\n                                                    client.mkdir(destinationDirectory, true, function(err){\r\n                                                        if(err){\r\n                                                            return done(err);\r\n                                                        }else{\r\n                                                            client.put(Buffer.concat(chunks), destinationFullPath, function(err){\r\n                                                                if(err){\r\n                                                                    return done(err);\r\n                                                                }else{\r\n                                                                    BAS_PERHAPS_STOP();\r\n                                                                    if(!--pending){done(null)};\r\n                                                                };\r\n                                                            });\r\n                                                        };\r\n                                                    });\r\n                                                });\r\n                                            };\r\n                                        });\r\n                                    };\r\n                                });\r\n                            };\r\n                        });\r\n                    };\r\n                });\r\n            };\r\n\r\n            client.list(remote_directory, function(err, list){\r\n                if(err){\r\n                    ftp.setTimeout(timeout);\r\n                    reject(err);\r\n                }else{\r\n                    var list = list.filter(function(file){return decodeName(file[\"name\"])==remote_name});\r\n                    if(list.length > 0){\r\n                        if(list[0][\"type\"]==\"d\"){\r\n                            сopyFolder(remote_path, copy_directory, function(err){\r\n                                if(err){\r\n                                    ftp.setTimeout(timeout);\r\n                                    reject(err);\r\n                                }else{\r\n                                    ftp.setTimeout(timeout);\r\n                                    resolve();\r\n                                };\r\n                            });\r\n                        }else{\r\n                            var chunks = [];\r\n                            client.get(remote_path, function(err, stream){\r\n                                if(err){\r\n                                    ftp.setTimeout(timeout);\r\n                                    reject(err);\r\n                                }else{\r\n                                    stream.on('data', function(chunk){\r\n                                        chunks.push(chunk);\r\n                                    });\r\n                                    stream.on('error', function(err){\r\n                                        ftp.setTimeout(timeout);\r\n                                        reject(err);\r\n                                    });\r\n                                    stream.on('end', function(){\r\n                                        client.mkdir(copy_directory, true, function(err){\r\n                                            if(err){\r\n                                                ftp.setTimeout(timeout);\r\n                                                reject(err);\r\n                                            }else{\r\n                                                client.put(Buffer.concat(chunks), copy_path, function(err){\r\n                                                    if(err){\r\n                                                        ftp.setTimeout(timeout);\r\n                                                        reject(err);\r\n                                                    }else{\r\n                                                        ftp.setTimeout(timeout);\r\n                                                        resolve();\r\n                                                    };\r\n                                                });\r\n                                            };\r\n                                        });\r\n                                    });\r\n                                };\r\n                            });\r\n                        };\r\n                    }else{\r\n                        ftp.setTimeout(timeout);\r\n                        reject('The file/folder \"' + remote_path + '\" does not exist');\r\n                    };\r\n                };\r\n            });\r\n            client.on('error', function(err){\r\n                ftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n            client.on('close', function close(){\r\n                reject(\"Connection closed\");\r\n            });\r\n        };\r\n    });\r\n}));\r\n\r\nfunction decodeName(name) {\r\n    return decodeURIComponent(escape(name))\r\n};",
            "DataName": "CopyFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\n\r\nvar command = [[FTP_NODE_PARAMETERS]][0];\r\nvar wait_finish = [[FTP_NODE_PARAMETERS]][1];\r\nvar pty = [[FTP_NODE_PARAMETERS]][2];\r\nvar id = [[FTP_NODE_PARAMETERS]][3];\r\nvar config = [[FTP_NODE_PARAMETERS]][4];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][5];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SSH\", function(err, ssh){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = ssh.client;\r\n            client.exec(command, {pty:pty}, function(err, stream){\r\n                if(err){\r\n                    ssh.setTimeout(timeout);\r\n                    reject(err);\r\n                }else{\r\n                    var standart_output = \"\";\r\n                    var error_output = \"\";\r\n                    if(wait_finish){\r\n                        stream.on('close', function(code, signal) {\r\n                            [[FTP_NODE_PARAMETERS]] = [standart_output, error_output];\r\n                            ssh.setTimeout(timeout);\r\n                            resolve();\r\n                        });\r\n                        stream.on('data', function(data) {\r\n                            standart_output += data.toString('utf8');\r\n                        });\r\n                        stream.stderr.on('data', function(data) {\r\n                            error_output += data.toString('utf8');\r\n                        });\r\n                    }else{\r\n                        [[FTP_NODE_PARAMETERS]] = [standart_output, error_output];\r\n                        ssh.setTimeout(timeout);\r\n                        resolve();\r\n                    };\r\n                };\r\n            });\r\n            client.on('error', function(err){\r\n                ssh.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n            client.on('close', function close(){\r\n                reject(\"Connection closed\");\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "RunCommandSSH",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar id = [[FTP_NODE_PARAMETERS]][1];\r\nvar config = [[FTP_NODE_PARAMETERS]][2];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][3];\r\nvar command = \"sha1sum -b \" + remote_path;\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SFTP\", function(err, sftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var sftp_client = sftp.client;\r\n            util.open_or_use_connection(id, config, \"SSH\", function(err, ssh){\r\n                if(err){\r\n                    reject(err);\r\n                }else{\r\n                    var client = ssh.client;\r\n                    var exists = sftp_client.exists(remote_path);\r\n                    exists.then(function(exist){\r\n                        if(exist){\r\n                            var stat = sftp_client.stat(remote_path);\r\n                            stat.then(function(stats){\r\n                                sftp.setTimeout(timeout);\r\n                                if(stats.isFile){\r\n                                    client.exec(command, function(err, stream){\r\n                                        if(err){\r\n                                            ssh.setTimeout(timeout);\r\n                                            reject(err);\r\n                                        }else{\r\n                                            var standart_output = \"\";\r\n                                            var error_output = \"\";\r\n                                            stream.on('close', function(code, signal){\r\n                                                if(standart_output.indexOf(\"sha1sum: command not found\") > -1 || error_output.indexOf(\"sha1sum: command not found\") > -1){\r\n                                                    ssh.setTimeout(timeout);\r\n                                                    reject('sha1sum not installed');\r\n                                                }else{\r\n                                                    if(error_output!=\"\"){\r\n                                                        ssh.setTimeout(timeout);\r\n                                                        reject(error_output);\r\n                                                    }else{\r\n                                                        [[FTP_NODE_PARAMETERS]] = standart_output.split(\" \")[0];\r\n                                                        ssh.setTimeout(timeout);\r\n                                                        resolve();\r\n                                                    };\r\n                                                };\r\n                                            });\r\n                                            stream.on('data', function(data) {\r\n                                                standart_output += data.toString('utf8');\r\n                                            });\r\n                                            stream.stderr.on('data', function(data) {\r\n                                                error_output += data.toString('utf8');\r\n                                            });\r\n                                        };\r\n                                    });\r\n                                    client.on('error', function(err){\r\n                                        ssh.setTimeout(timeout);\r\n                                        reject(err);\r\n                                    });\r\n                                    client.on('close', function close(){\r\n                                        reject(\"Connection closed\");\r\n                                    });\r\n                                }else{\r\n                                    ssh.setTimeout(timeout);\r\n                                    reject('\"' + remote_path + '\" is not a file');\r\n                                };\r\n                            });\r\n                            stat.catch(function(err){\r\n                                sftp.setTimeout(timeout);\r\n                                reject(err);\r\n                            });\r\n                        }else{\r\n                            sftp.setTimeout(timeout);\r\n                            ssh.setTimeout(timeout);\r\n                            reject('The file/folder \"' + remote_path + '\" does not exist');\r\n                        };\r\n                    });\r\n                    exists.catch(function(err){\r\n                        sftp.setTimeout(timeout);\r\n                        ssh.setTimeout(timeout);\r\n                        reject(err);\r\n                    });\r\n                };\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "CalculateChecksumSSH",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar destination_directory = [[FTP_NODE_PARAMETERS]][1];\r\nvar id = [[FTP_NODE_PARAMETERS]][2];\r\nvar config = [[FTP_NODE_PARAMETERS]][3];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][4];\r\nvar remote_name = path.basename(remote_path);\r\nvar remote_directory = path.dirname(remote_path);\r\nvar destination_path = destination_directory + \"/\" + remote_name;\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SFTP\", function(err, sftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = sftp.client;\r\n            function downloadFile(remote, destination){\r\n                var fastGet = client.fastGet(remote, destination);\r\n                fastGet.then(function(){\r\n                    sftp.setTimeout(timeout);\r\n                    resolve();\r\n                });\r\n                fastGet.catch(function(err){\r\n                    sftp.setTimeout(timeout);\r\n                    reject(err);\r\n                });\r\n            };\r\n\r\n            function downloadFolder(remote, destination, done){\r\n                ensureDirectoryExistence(destination + \"/test.txt\");\r\n                var list = client.list(remote);\r\n                list.then(function(list){\r\n                    var pending = list.length;\r\n                    if(!pending){return done(null)};\r\n                    list.forEach(function(file){\r\n                        var fileName = file[\"name\"];\r\n                        var fileType = file[\"type\"];\r\n                        var remoteFullPath = remote + \"/\" + fileName;\r\n                        var destinationFullPath = destination + \"/\" + fileName;\r\n                        if(fileType==\"d\"){\r\n                            downloadFolder(remoteFullPath, destinationFullPath, function(err){\r\n                                if(err){\r\n                                    return done(err);\r\n                                }else{\r\n                                    BAS_PERHAPS_STOP();\r\n                                    if(!--pending){done(null)};\r\n                                };\r\n                            });\r\n                        }else{\r\n                            var fastGet = client.fastGet(remoteFullPath, destinationFullPath);\r\n                            fastGet.then(function(){\r\n                                BAS_PERHAPS_STOP();\r\n                                if(!--pending){done(null)};\r\n                            });\r\n                            fastGet.catch(function(err){\r\n                                return done(err);\r\n                            });\r\n                        };\r\n                    });\r\n                });\r\n                list.catch(function(err){\r\n                    done(err);\r\n                });\r\n            };\r\n\r\n            var exists = client.exists(remote_path);\r\n            exists.then(function(exist){\r\n                if(exist){\r\n                    var stat = client.stat(remote_path);\r\n                    stat.then(function(stats){\r\n                        var isDirectory = stats.isDirectory;\r\n                        if(!isDirectory && fs.existsSync(destination_directory)){\r\n                            fs.stat(destination_directory, function(err, stats){\r\n                                if(err){\r\n                                    sftp.setTimeout(timeout);\r\n                                    reject(err);\r\n                                }else{\r\n                                    if(stats.isDirectory()){\r\n                                        downloadFile(remote_path, destination_path);\r\n                                    }else{\r\n                                        downloadFile(remote_path, destination_directory);\r\n                                    }\r\n                                };\r\n                            });\r\n                        }else{\r\n                            ensureDirectoryExistence(destination_path);\r\n                            if(isDirectory){\r\n                                downloadFolder(remote_path, destination_directory, function(err){\r\n                                    if(err){\r\n                                        sftp.setTimeout(timeout);\r\n                                        reject(err);\r\n                                    }else{\r\n                                        sftp.setTimeout(timeout);\r\n                                        resolve();\r\n                                    };\r\n                                });\r\n                            }else{\r\n                                downloadFile(remote_path, destination_path);\r\n                            };\r\n                        };\r\n                    });\r\n                    stat.catch(function(err){\r\n                        sftp.setTimeout(timeout);\r\n                        reject(err);\r\n                    });\r\n                }else{\r\n                    sftp.setTimeout(timeout);\r\n                    reject('The file/folder \"' + remote_path + '\" does not exist');\r\n                };\r\n            });\r\n            exists.catch(function(err){\r\n                sftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n        };\r\n    });\r\n}));\r\n\r\nfunction ensureDirectoryExistence(filePath){\r\n    var dirname = path.dirname(filePath);\r\n    if(fs.existsSync(dirname)){\r\n        return true;\r\n    };\r\n    ensureDirectoryExistence(dirname);\r\n    fs.mkdirSync(dirname);\r\n};",
            "DataName": "DownloadSFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar file_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar file_type = [[FTP_NODE_PARAMETERS]][1];\r\nvar id = [[FTP_NODE_PARAMETERS]][2];\r\nvar config = [[FTP_NODE_PARAMETERS]][3];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][4];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SFTP\", function(err, sftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = sftp.client;\r\n            function ensureDirectoryExistence(filePath, done){\r\n                var dirname = path.dirname(filePath);\r\n                var exists = client.exists(dirname);\r\n                exists.then(function(exist){\r\n                    if(exist){\r\n                        done(null);\r\n                    }else{\r\n                        var mkdir = client.mkdir(dirname, true);\r\n                        mkdir.then(function(){\r\n                            done(null);\r\n                        });\r\n                        mkdir.catch(function(err){\r\n                            done(err);\r\n                        });\r\n                    };\r\n                });\r\n                exists.catch(function(err){\r\n                    done(err);\r\n                });\r\n            };\r\n\r\n            var exists = client.exists(file_path);\r\n            exists.then(function(exist){\r\n                if(exist){\r\n                    sftp.setTimeout(timeout);\r\n                    resolve();\r\n                }else{\r\n                    ensureDirectoryExistence(file_path, function(err){\r\n                        if(err){\r\n                            sftp.setTimeout(timeout);\r\n                            reject(err);\r\n                        }else{\r\n                            if(file_type==\"d\"){\r\n                                var mkdir = client.mkdir(file_path, true);\r\n                                mkdir.then(function(){\r\n                                    sftp.setTimeout(timeout);\r\n                                    resolve();\r\n                                });\r\n                                mkdir.catch(function(err){\r\n                                    sftp.setTimeout(timeout);\r\n                                    reject(err);\r\n                                });\r\n                            }else{\r\n                                var put = client.put(Buffer.from('', 'utf8'), file_path);\r\n                                put.then(function(){\r\n                                    sftp.setTimeout(timeout);\r\n                                    resolve();\r\n                                });\r\n                                put.catch(function(err){\r\n                                    sftp.setTimeout(timeout);\r\n                                    reject(err);\r\n                                });\r\n                            };\r\n                        };\r\n                    });\r\n                };\r\n            });\r\n            exists.catch(function(err){\r\n                sftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "CreateSFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar file_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar file_type = [[FTP_NODE_PARAMETERS]][1];\r\nvar id = [[FTP_NODE_PARAMETERS]][2];\r\nvar config = [[FTP_NODE_PARAMETERS]][3];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][4];\r\nvar file_name = path.basename(file_path);\r\nvar file_directory = path.dirname(file_path);\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"FTP\", function(err, ftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = ftp.client;\r\n            client.list(file_directory, function(err, list){\r\n                if(err){\r\n                    ftp.setTimeout(timeout);\r\n                    reject(err);\r\n                }else{\r\n                    var list = list.filter(function(file){return decodeURIComponent(escape(file[\"name\"]))==file_name});\r\n                    if(list.length > 0){\r\n                        ftp.setTimeout(timeout);\r\n                        resolve();\r\n                    }else{\r\n                        client.mkdir(file_directory, true, function(err){\r\n                            if(err){\r\n                                ftp.setTimeout(timeout);\r\n                                reject(err);\r\n                            }else{\r\n                                if(file_type==\"d\"){\r\n                                    client.mkdir(file_path, true, function(err){\r\n                                        if(err){\r\n                                            ftp.setTimeout(timeout);\r\n                                            reject(err);\r\n                                        }else{\r\n                                            ftp.setTimeout(timeout);\r\n                                            resolve();\r\n                                        };\r\n                                    });\r\n                                }else{\r\n                                    client.put(Buffer.from('', 'utf8'), file_path, function(err){\r\n                                        if(err){\r\n                                            ftp.setTimeout(timeout);\r\n                                            reject(err);\r\n                                        }else{\r\n                                            ftp.setTimeout(timeout);\r\n                                            resolve();\r\n                                        };\r\n                                    });\r\n                                };  \r\n                            };\r\n                        });\r\n                    };\r\n                };\r\n            });\r\n            client.on('error', function(err){\r\n                ftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n            client.on('close', function close(){\r\n                reject(\"Connection closed\");\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "CreateFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar base64 = [[FTP_NODE_PARAMETERS]][1];\r\nvar id = [[FTP_NODE_PARAMETERS]][2];\r\nvar config = [[FTP_NODE_PARAMETERS]][3];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][4];\r\nvar encoding = base64 ? 'base64' : 'utf8';\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"SFTP\", function(err, sftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = sftp.client;\r\n            var exists = client.exists(remote_path);\r\n            exists.then(function(exist){\r\n                if(exist){\r\n                    var getf = client.get(remote_path);\r\n                    getf.then(function(data){\r\n                        [[FTP_NODE_PARAMETERS]] = data.toString(encoding);\r\n                        sftp.setTimeout(timeout);\r\n                        resolve();\r\n                    });\r\n                    getf.catch(function(err){\r\n                        sftp.setTimeout(timeout);\r\n                        reject(err);\r\n                    });\r\n                }else{\r\n                    sftp.setTimeout(timeout);\r\n                    reject('The file/folder \"' + remote_path + '\" does not exist');\r\n                };\r\n            });\r\n            exists.catch(function(err){\r\n                sftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n        };\r\n    })\r\n}));",
            "DataName": "ReadFileSFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const util = require(\"../UtilFTP\");\r\nconst path = require('path');\r\n\r\nvar remote_path = [[FTP_NODE_PARAMETERS]][0];\r\nvar base64 = [[FTP_NODE_PARAMETERS]][1];\r\nvar id = [[FTP_NODE_PARAMETERS]][2];\r\nvar config = [[FTP_NODE_PARAMETERS]][3];\r\nvar timeout = [[FTP_NODE_PARAMETERS]][4];\r\nvar encoding = base64 ? 'base64' : 'utf8';\r\nvar remote_name = path.basename(remote_path);\r\nvar remote_directory = path.dirname(remote_path);\r\nvar chunks = [];\r\n\r\nawait (new Promise((resolve, reject) => {\r\n    util.open_or_use_connection(id, config, \"FTP\", function(err, ftp){\r\n        if(err){\r\n            reject(err);\r\n        }else{\r\n            var client = ftp.client;\r\n            client.list(remote_directory, function(err, list){\r\n                if(err){\r\n                    ftp.setTimeout(timeout);\r\n                    reject(err);\r\n                }else{\r\n                    var list = list.filter(function(file){return decodeURIComponent(escape(file[\"name\"]))==remote_name});\r\n                    if(list.length > 0){\r\n                        client.get(remote_path, function(err, stream){\r\n                            if(err){\r\n                                ftp.setTimeout(timeout);\r\n                                reject(err);\r\n                            }else{\r\n                                stream.on('data', function(chunk){\r\n                                    chunks.push(chunk);\r\n                                });\r\n                                stream.on('error', function(err){\r\n                                    ftp.setTimeout(timeout);\r\n                                    reject(err);\r\n                                });\r\n                                stream.on('end', function(){\r\n                                    [[FTP_NODE_PARAMETERS]] = Buffer.concat(chunks).toString(encoding);\r\n                                    ftp.setTimeout(timeout);\r\n                                    resolve();\r\n                                });\r\n                            };\r\n                        });\r\n                    }else{\r\n                        ftp.setTimeout(timeout);\r\n                        reject('The file/folder \"' + remote_path + '\" does not exist');\r\n                    };\r\n                };\r\n            });\r\n            client.on('error', function(err){\r\n                ftp.setTimeout(timeout);\r\n                reject(err);\r\n            });\r\n            client.on('close', function close(){\r\n                reject(\"Connection closed\");\r\n            });\r\n        };\r\n    });\r\n}));",
            "DataName": "ReadFileFTP",
            "DataType": 0,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        },
        {
            "Data": "const sftp = require('ssh2-sftp-client');\nconst ftp = require('ftp');\nconst ssh = require('ssh2');\nvar self = this;\n\nthis.open_or_use_connection = function(id, config, protocol, done){\n    if(typeof ftp_connections==\"undefined\"){\n        ftp_connections = {};\n    };\n    \n    if(typeof ftp_connections[id]==\"undefined\"){\n        ftp_connections[id] = {};\n    };\n\n    if(protocol===\"SFTP\"){\n        if(typeof ftp_connections[id].sftp==\"undefined\" || typeof ftp_connections[id].sftp.client.sftp==\"undefined\" || JSON.stringify(ftp_connections[id].sftp.config)!=JSON.stringify(config)){\n            if(typeof ftp_connections[id].sftp==\"undefined\" || JSON.stringify(ftp_connections[id].sftp.config)!=JSON.stringify(config)){\n                ftp_connections[id].sftp = {\n                    id: id,\n                    config: config,\n                    client: new sftp(),\n                    timeout: 0,\n                    close: function(id){\n                        ftp_connections[id].sftp.client.end();\n                        return ftp_connections[id].sftp.delete();\n                    },\n                    setTimeout: function(timeout){this.timeout = setTimeout(this.close, timeout, this.id)},\n                    clearTimeout: function(){clearTimeout(this.id)},\n                    delete: function(){delete ftp_connections[this.id].sftp}\n                };\n            };\n            var sftp_obj = ftp_connections[id].sftp;\n            var connect = sftp_obj.client.connect(config);\n            connect.then(function(){\n                return done(null, sftp_obj);\n            });\n            connect.catch(function(err){\n                sftp_obj.delete();\n                return done(err);\n            });\n        }else{\n            ftp_connections[id].sftp.clearTimeout();\n            if(typeof ftp_connections==\"undefined\" || typeof ftp_connections[id]==\"undefined\" || typeof ftp_connections[id].sftp==\"undefined\" || typeof ftp_connections[id].sftp.client.sftp==\"undefined\"){\n                self.open_or_use_connection(id, config, protocol, done);\n            }else{\n                done(null, ftp_connections[id].sftp);\n            };\n        };\n    };\n\n    if(protocol===\"FTP\"){\n        if(typeof ftp_connections[id].ftp==\"undefined\" || JSON.stringify(ftp_connections[id].ftp.config)!=JSON.stringify(config)){\n            ftp_connections[id].ftp = {\n                id: id,\n                config: config,\n                client: new ftp(),\n                timeout: 0,\n                close: function(id){\n                    ftp_connections[id].ftp.client.end();\n                },\n                setTimeout: function(timeout){this.timeout = setTimeout(this.close, timeout, this.id)},\n                clearTimeout: function(){clearTimeout(this.timeout)},\n                delete: function(){delete ftp_connections[this.id].ftp},\n                closeEventHandler: async function(){\n                    await once(this.client, 'close');\n                    this.delete();\n                    return;\n                }\n            };\n            var ftp_obj = ftp_connections[id].ftp;\n            ftp_obj.client.connect(config);\n            ftp_obj.client.on('ready', function(){\n                return done(null, ftp_obj);\n            });\n            ftp_obj.client.on('error', function(err){\n                ftp_obj.delete();\n                return done(err);\n            });\n            ftp_obj.closeEventHandler();\n        }else{\n            ftp_connections[id].ftp.clearTimeout();\n            if(typeof ftp_connections==\"undefined\" || typeof ftp_connections[id]==\"undefined\" || typeof ftp_connections[id].ftp==\"undefined\"){\n                self.open_or_use_connection(id, config, protocol, done);\n            }else{\n                done(null, ftp_connections[id].ftp);\n            };\n        };\n    };\n    if(protocol===\"SSH\"){\n        if(typeof ftp_connections[id].ssh==\"undefined\" || JSON.stringify(ftp_connections[id].ssh.config)!=JSON.stringify(config)){\n            ftp_connections[id].ssh = {\n                id: id,\n                config: config,\n                client: new ssh(),\n                timeout: 0,\n                close: function(id){\n                    ftp_connections[id].ssh.client.end();\n                },\n                setTimeout: function(timeout){this.timeout = setTimeout(this.close, timeout, this.id)},\n                clearTimeout: function(){clearTimeout(this.timeout)},\n                delete: function(){delete ftp_connections[this.id].ssh},\n                closeEventHandler: async function(){\n                    await once(this.client, 'close');\n                    this.delete();\n                    return;\n                }\n            };\n            var ssh_obj = ftp_connections[id].ssh;\n            ssh_obj.client.connect(config);\n            ssh_obj.client.on('ready', function(){\n                return done(null, ssh_obj);\n            });\n            ssh_obj.client.on('error', function(err){\n                ssh_obj.delete();\n                return done(err);\n            });\n            ssh_obj.closeEventHandler();\n        }else{\n            ftp_connections[id].ssh.clearTimeout();\n            if(typeof ftp_connections==\"undefined\" || typeof ftp_connections[id]==\"undefined\" || typeof ftp_connections[id].ssh==\"undefined\"){\n                self.open_or_use_connection(id, config, protocol, done);\n            }else{\n                done(null, ftp_connections[id].ssh);\n            };\n        };\n    };\n};",
            "DataName": "UtilFTP",
            "DataType": 1,
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3"
        }
    ],
    "engine": [
        "engine.js"
    ],
    "icon": "FTP.png",
    "info": {
        "en": "Module for working with remote servers via FTP, SFTP, SSH protocols.",
        "ru": "Модуль для работы с удаленными серверами посредством FTP, SFTP, SSH протоколов."
    },
    "is_autogenerated": true,
    "languages": [
        {
            "Name": "Node",
            "Version": "12.18.3"
        }
    ],
    "localize": {
		"Port": {"ru":"Порт"},
		"File": {"ru":"Файл"},
		"List": {"ru":"Список"},
		"Folder": {"ru":"Папка"},
        "manual":{"ru":"мануале"},
		"is empty": {"ru":"пуст"},
		"Username": {"ru":"Логин"},
		"Password": {"ru":"Пароль"},
		"Protocol": {"ru":"Протокол"},
		"All files": {"ru":"Все файлы"},
		"Host name": {"ru":"Имя хоста"},
        "Instructions":{"ru":"Инструкции"},
		"Is file": {"ru":"Является файлом"},
		"Search files": {"ru":"Искать файлы"},
		"Append file": {"ru":"Дописывать файл"},
		"Search folders": {"ru":"Искать папки"},
		"Is directory": {"ru":"Является папкой"},
		"Is not file": {"ru":"Не является файлом"},
		"Can be blank": {"ru":"Может быть пустым"},
		"Error output": {"ru":"Результат с ошибкой"},
		"Destination path": {"ru":"Путь назначения"},
		"Timeout (seconds)": {"ru":"Таймаут (секунд)"},
		"All text files": {"ru":"Все текстовые файлы"},
		"File/Folder size": {"ru":"Размер файла/папки"},
		"Is not directory": {"ru":"Не является папкой"},
		"Standard output": {"ru":"Стандартный результат"},
		"Remote file path": {"ru":"Удаленный путь к файлу"},
		"Search in subfolders": {"ru":"Искать в подпапках"},
		"Show CPU usage": {"ru":"Показать использование ЦП"},
		"All JavaScript files": {"ru":"Все JavaScript файлы"},
		"File/Folder exists.": {"ru":"Файл/Папка существует."},
		"File or folder path": {"ru":"Путь к файлу или папке"},
		"Dump mysql databases": {"ru":"Дамп базы данных mysql"},
		"Show disk usage": {"ru":"Показать использование диска"},
		"Last modified date": {"ru":"Дата последнего изменения"},
		"File/Folder directory": {"ru":"Директория файла/папки"},
		"Variable not specified": {"ru":"Переменная не указаны"},
		"File/Folder name mask": {"ru":"Маска имени файла/папки"},
		"Variables not specified": {"ru":"Переменные не указаны"},
		"File/Folder existence": {"ru":"Существование файла/папки"},
		"Save in base64 format": {"ru":"Сохранить в формате base64"},
		"Remote destination path": {"ru":"Удаленный путь назначения"},
		"Port of the remote server.": {"ru":"Порт удаленного сервера."},
		"Close FTP/SSH connection.": {"ru":"Закрыть FTP/SSH соединение."},
		"Show last lines of log": {"ru":"Показать последние строки лога"},
		"File/Folder does not exist.": {"ru":"Файл/Папка не существует."},
		"Add line ending symbol": {"ru":"Добавить символ окончания строки"},
		"Password of the remote server.": {"ru":"Пароль удаленного сервера."},
		"Remote directory to search": {"ru":"Удаленная директория для поиска"},
		"Data is in base64 format": {"ru":"Данные представлены в формате base64"},
		"Remote path to file or folder": {"ru":"Удаленный путь к файлу или папке"},
		"All JavaScript and text files": {"ru":"Все JavaScript и текстовые файлы"},
		"Default port for FTP protocol": {"ru":"Порт по умолчанию для FTP протокола"},
		"Remote path to new file/folder": {"ru":"Удаленный путь к новому файлу/папке"},
		"Username of the remote server.": {"ru":"Имя пользователя удаленного сервера."},
		"Variable to save the result": {"ru":"Переменная, в которую сохранить результат"},
		"Run in current working directory": {"ru":"Запустить в текущей рабочей директории"},
		"New remote path to file or folder": {"ru":"Новый удаленный путь к файлу или папке"},
		"Host (URL or IP) of the remote server.": {"ru":"Хост (URL или IP) удаленного сервера."},
		"Create file/folder on remote server.": {"ru":"Создать файл/папку на удаленном сервере."},
		"Delete file/folder from remote server.": {"ru":"Удалить файл/папку с удаленного сервера."},
		"Write list to file on remote server.": {"ru":"Записать список в файл на удаленном сервере."},
		"Default port for SFTP and SSH protocols": {"ru":"Порт по умолчанию для SFTP и SSH протоколов"},
		"Execute bash command on a remote server.": {"ru":"Выполнить bash команду на удаленном сервере."},
		"Write data to a file on a remote server.": {"ru":"Записать данные в файл на удаленном сервере."},
		"Automatically detect port based on protocol": {"ru":"Автоматически определять порт по протоколу"},
		"This action only works with the SSH protocol.": {"ru":"Данное действие работает только с SSH протоколом."},
        "If file/folder is missing no error will occur.":{"ru":"Если файл/папка отсутствует, ошибки не произойдет."},
		"Configure access to a remote FTP or SSH server.": {"ru":"Настроить доступ к удаленному FTP или SSH серверу."},
		"If the specified path is missing it will be created.": {"ru":"Если указанный путь отсутствует, он будет создан."},
		"Working folder in which bash script will be executed.": {"ru":"Рабочая папка, в которой будет выполняться bash."},
		"This action works with both files and folders.": {"ru":"Данное действие работает как с файлами, так и с папками."},
		"This variable will contain the size of the file/folder.": {"ru":"Эта переменная будет содержать размер файла/папки."},
        "Each list element will be added as separate line.":{"ru":"Каждый элемент списка будет добавлен как отдельная строка."},
		"The path to the required file/folder on the remote server.": {"ru":"Путь до нужного файла/папки на удаленном сервере."},
		"The command which needs to be executed on the remote server.": {"ru":"Команда которую нужно выполнить на удаленном сервере."},
		"Get information about a file located on a remote server.": {"ru":"Получить информацию о файле находящемся на удаленном сервере."},
		"Copy file/folder to another location on the remote server.": {"ru":"Скопировать файл/папку в другое место на удаленном сервере."},
		"If a non-existent file path is specified, it will be created.": {"ru":"Если указан несуществующий путь к файлу, он будет создан."},
		"You can specify several masks by separating them with \";\".": {"ru":"Можно указать несколько масок, разделив их при помощи \";\"."},
		"The path on the remote server to the file/folder after moving.": {"ru":"Путь на удаленном сервере к файлу/папке после перемещения."},
		"The path to the file on the remote server which will be read.": {"ru":"Путь к файлу на удаленном сервере, который нужно прочитать."},
		"Move the file/folder to another location on the remote server.": {"ru":"Переместить файл/папку в другое место на удаленном сервере."},
		"Get the checksum of the file located on the remote server.": {"ru":"Получить контрольную сумму файла, находящегося на удаленном сервере."},
		"If a non-existent destination path is specified, it will be created.": {"ru":"Если указан несуществующий путь назначения, он будет создан."},
		"Upload the file/folder to the specified location on the remote server.": {"ru":"Загрузить файл/папку в указанное место на удаленном сервере."},
		"This variable will contain the result of the command with error.": {"ru":"Эта переменная будет содержать результат выполнения команды с ошибкой."},
		"This variable will contain the standard output of the command.": {"ru":"Эта переменная будет содержать стандартный результат выполнения команды."},
		"For binary data use \"Save in base64 format\" option.": {"ru":"Для работы с бинарными данными используйте параметр \"Сохранить в формате base64\"."},
		"Search for files/folders in the specified directory on the remote server.": {"ru":"Поиск файлов/папок в указанной директории на удаленном сервере."},
		"Data that will be written to the specified file on the remote server.": {"ru":"Данные которые будут записаны в указанный файл на удаленном сервере."},
		"The path on the remote server to the file/folder which needs to be deleted.": {"ru":"Путь на удаленном сервере к файлу/папке который нужно удалить."},
		"The path to the file on the remote server in which data will be written.": {"ru":"Путь к файлу на удаленном сервере, в который нужно записать данные."},
		"This variable will contain the date the file/folder was last modified.": {"ru":"Эта переменная будет содержать дату последнего изменения файла/папки."},
		"The path to the file on the remote server in which list will be written.": {"ru":"Путь к файлу на удаленном сервере, в который нужно записать список."},
		"The path on the remote server to the file/folder which needs to be moved.": {"ru":"Путь на удаленном сервере к файлу/папке который нужно переместить."},
		"The path to the file/folder which needs to be uploaded to the remote server.": {"ru":"Путь к файлу/папке который нужно загрузить на удаленный сервер."},
		"The path on the remote server to the file/folder which needs to be copied.": {"ru":"Путь на удаленном сервере к файлу/папке который нужно скопировать."},
		"The path on the remote server to the file/folder which needs to be downloaded.": {"ru":"Путь на удаленном сервере к файлу/папке который нужно скачать."},
		"The list that will be written to the specified file on the remote server.": {"ru":"Список, который будет записан в указанный файл на удаленном сервере."},
		"The command  can have multiple lines, you can learn more about bash in": {"ru":"Команда может иметь несколько строк, подробнее о bash вы можете узнать в"},
		"Read a file on a remote server and store its contents into a variable.": {"ru":"Читать файл на удаленном сервере и сохранить его содержимое в переменную."},
		"The protocol by which the connection to the remote server will be made.": {"ru":"Протокол по которому будет производиться подключение к удаленному серверу."},
		"Check if a file/folder exists at the specified path on the remote server.": {"ru":"Проверить существует ли файл/папка по заданному пути на удаленном сервере."},
		"Download file/folder from a remote server and save to the specified location.": {"ru":"Скачать файл/папку с удаленного сервера и сохранить в указанное место."},
		"The resulting list can be processed using actions from the \"List\" module.": {"ru":"Полученный список можно обработать с помощью действий из модуля \"Список\"."},
		"If \"Search files\" option is enabled, the final list will include files.": {"ru":"Если параметр \"Искать файлы\" включен, в итоговый список будут включены файлы."},
		"This action can be used to rename a file/folder on a remote server.": {"ru":"Данное действие можно использовать, чтобы переименовать файл/папку на удаленном сервере."},
		"If \"Search folders\" option is enabled, the final list will include folders.": {"ru":"Если параметр \"Искать папки\" включен, в итоговый список будут включены папки."},
		"If connection is already closed or not open yet, this action will do nothing.": {"ru":" Если соединение уже закрыто или ещё не открыто, это действие ничего не сделает."},
		"The path on the remote server to the location where the file will be copied.": {"ru":"Путь на удаленном сервере к месту куда будет скопирован файл или содержимое папки."},
		"The path to the directory on the remote server in which the search will be performed.": {"ru":"Путь к директории на удаленном сервере в которой будет производиться поиск."},
		"Using a mask, you can search for files/folders with a specific name or extension.": {"ru":"С помощью маски можно искать файлы/папки с определенным именем или расширением."},
        "Exact autoclose timeout is specified in \"Configure FTP/SSH\" action.":{"ru":"Точный значение максимального времени ожидания можно задать в действии \"Настроить FTP/SSH\"."},
		"To write the list to a file correctly, use the \"Write list to file\" action.": {"ru":"Для корректной записи списка в файл используйте действие \"Записать список в файл\"."},
		"If you need to get a list from a file use the \"Read file to list\" action.": {"ru":"Если вам нужно получить список из файла, используйте действие \"Читать файл в список\"."},
		"The path on the remote server to the file/folder whose existence needs to be checked.": {"ru":"Путь на удаленном сервере к файлу/папке существование которого нужно проверить."},
		"The path to the file on the remote server, the checksum for which needs to be obtained.": {"ru":"Путь к файлу на удаленном сервере, контрольную сумму которого нужно получить."},
		"The path on the remote server to the new file/folder which will be available after creation.": {"ru":"Путь на удаленном сервере к новому файлу/папке доступный после создания."},
		"If uploaded files already exist along the destination path, they will be overwritten.": {"ru":"Если загруженные файлы уже существуют по пути назначения, они будут перезаписаны."},
		"This variable will contain the path to the directory where the file/folder is located.": {"ru":"Эта переменная будет содержать путь к директории в которой находится файл/папка."},
		"The path on the remote server to the file/folder about which information will be obtained.": {"ru":"Путь на удаленном сервере к файлу/папке о котором нужно получить информацию."},
		"If downloaded files already exist along the destination path, they will be overwritten.": {"ru":"Если скачиваемые файлы уже существуют по пути назначения, они будут перезаписаны."},
		"sha1sum must be installed on the server. Learn more about sha1sum": {"ru":"Чтобы это действие работало, на сервере должен быть установлен sha1sum. Подробнее о sha1sum можно узнать"},
		"This variable will be set to true or false depending on the existence of the file/folder.": {"ru":"Эта переменная будет равна true или false в зависимости от существования файла/папки."},
		"In order to execute this action correctly you need to run \"Configure FTP/SSH\" action first.": {"ru":"Для правильной работы необходимо сначала выполнить действие \"Настроить FTP/SSH\"."},
		"The resulting list will contain not only the names of the files/folders, but their full path.": {"ru":"Полученный список будет содержать не только названия файлов/папок, но их полный путь."},
		"If you need to save the file directly to computer, use the \"Download file/folder\" action.": {"ru":"Если вам нужно сохранить файл сразу на компьютер, используйте действие \"Скачать файл/папку\"."},
		"If you just need to save the contents of a file to a variable, use the \"Read file\" action.": {"ru":"Если вам просто нужно сохранить содержимое файла в переменную, используйте действие \"Читать файл\"."},
		"This action should be called once before any other action that works with the remote server.": {"ru":"Это действие нужно вызвать один раз перед любым другим действием, которое работает с удаленным сервером."},
		"If a resource is specified in the \"Destination path\" parameter, resource location will be used.": {"ru":"Если в параметре \"Путь назначения\" указан ресурс, вместо содержимого ресурса будет браться его расположение."},
		"This variable will be true or false depending on whether the specified path leads to the file is or not.": {"ru":"Эта переменная будет равна true или false в зависимости от того ведет ли указанный путь к файлу или нет."},
		"This variable will be true or false depending on whether the specified path leads to the directory is or not.": {"ru":"Эта переменная будет равна true или false в зависимости от того ведет ли указанный путь к папке или нет."},
		"Variable in which, after the successful execution of the action, the contents of the read file will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записано содержимое прочитанного файла."},
		"Read the file on the remote server, convert its contents to a list, and store this list into a variable.": {"ru":"Прочитать файл на удаленном сервере, преобразовать его содержимое в список и сохранить этот список в переменную."},
        "If a resource is specified in the \"File or folder path\" parameter, resource location will be used.": {"ru":"Если в параметре \"Путь к файлу или папке\" указан ресурс, вместо содержимого ресурса будет браться его расположение."},
		"Variable in which, after the successful execution of the action, the checksum of the specified file will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записана контрольная сумма указанного файла."},
        "This action is optional because connection is closed automatically if it is not used for a long time.": {"ru":"Это действие не является обязательным, так как соединение закрывается автоматически если оно не использовалось длительное время."},
		"The file/folder will be copied to the remote server, and the original file/folder on the computer will remain unchanged.": {"ru":"Файл/Папка будет скопирован на удаленный сервер, а исходный файл/папка на компьютере останется без изменений."},
		"The file/folder will be copied to your computer, and the original file/folder on the remote server will remain unchanged.": {"ru":"Файл/Папка будет скопирован на компьютер, а исходный файл/папка на удаленном сервере останется без изменений."},
		"The list can be obtained using the \"Read file to list\" action or create using actions from the \"List\" module.": {"ru":"Список можно получить с помощью действия \"Читать файл в список\" или создать с помощью действий из модуля \"Список\"."},
		"The file/folder will be copied to a new location on the remote server, and the original file/folder will remain unchanged.": {"ru":"Файл/Папка будет скопирован в новое место на удаленном сервере, а исходный файл/папка останется без изменений."},
		"The path to the location on the remote server where the uploaded file or the contents of the uploaded folder will be saved.": {"ru":"Путь к месту на удаленном сервере в которое будет сохранен загруженный файл или содержимое загруженной папки."},
		"The path to the location where the file downloaded from the remote server or the contents of the downloaded folder will be saved.": {"ru":"Путь к месту в которое будет сохранен скачанный с удаленного сервера файл или содержимое скачанной папки."},
		"If the data is in base64 format, use the \"Data is in base64 format\" parameter for correct writing to the file.": {"ru":"Если данные имеют формат base64, используйте параметр \"Данные представлены в формате base64\" для корректной записи в файл."},
		"Variable in which, after the successful execution of the action, the list obtained from the contents of the file will be written.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записан список полученный из содержимого файла."},
        "You don't need to close connection explicitly, it will be closed automatically after timeout or when the script will stop.": {"ru":"Вам не нужно специально закрывать соединение, оно будет закрыто автоматически по истечении таймаута или при остановке скрипта."},
		"File/Folder name mask for filtering. The final list will include only files/folders whose names match the mask.": {"ru":"Маска имен файлов/папок по которой будет производиться фильтрация. В итоговый список войдут только файлы/папки чьи имена подходят под маску."},
		"This action will return true or false depending on the existence of the file/folder. This result may be used with \"If\" action.": {"ru":"Данное действие вернет true или false в зависимости от существования файла/папки. Результат может быть использован вместе с действием \"If\""},
        "Move a folder can take a long time, so it's best to increase the action timeout by clicking on the hourglass next to the cancel button.": {"ru":"Перемещение папки может занять много времени, поэтому лучше увеличить таймаут действия, нажав на песочные часы рядом с кнопкой отмены."},
		"Copy a folder can take a long time, so it is better to increase the action timeout by clicking on the hourglass next to the cancel button.": {"ru":"Копирование папки может занять много времени, поэтому лучше увеличить таймаут действия, нажав на песочные часы рядом с кнопкой отмены."},
		"Uploading a folder can take a long time, so it is better to increase the action timeout by clicking on the hourglass next to the cancel button.": {"ru":"Загрузка папки может занять много времени, поэтому лучше увеличить таймаут действия, нажав на песочные часы рядом с кнопкой отмены."},
		"Downloading a folder can take a long time, so it is better to increase the action timeout by clicking on the hourglass next to the cancel button.": {"ru":"Скачивание папки может занять много времени, поэтому лучше увеличить таймаут действия, нажав на песочные часы рядом с кнопкой отмены."},
        "SFTP (Secure File Transfer Protocol) is an alternative to FTP that also allows you to transfer files, but adds a layer of security to the process.":{"ru":"SFTP (Secure File Transfer Protocol) - альтернатива FTP, которая также позволяет передавать файлы, но добавляет шифрование к соединению."},
		"Images obtained with the \"Save in base64 format\" option can be used in the \"Solve Captcha\" action or in the \"Image processing\" module.": {"ru":"Изображения, полученные с параметром \"Сохранить в формате base64\", можно использовать в действии \"Решить Капчу\" или в модуле \"Обработка изображений\"."},
		"If you want the data to be written on more than one line when adding new data to the file, use \"Add line ending symbol\" option.": {"ru":"Если вы хотите, чтобы при добавлении новых данных в файл они записывались не в одну строку с уже имеющимися, используйте параметр \"Добавить символ окончания строки\"."},
		"Working folder by default is the home folder of current user, you may want to change it with \"Working folder\" parameter or by running \"cd\" command.": {"ru":"Рабочая папка по умолчанию - это домашняя папка текущего пользователя, вы можете изменить её с помощью параметра \"Рабочая папка\" или запустив команду \"cd\"."},
		"If an error occurred while execute action, the thread will stop with fail message. If you want to continue thread, use \"Ignore errors\" action.":{"ru":"Если во время выполнения действия произойдет ошибка, поток остановится с сообщением об ошибке. Если вы хотите продолжить работу, используйте действие \"Игнорировать ошибки\"."},
		"If \"Search in subfolders\" option is enabled, the search will be performed not only in the specified directory, but also recursively in all folders that are in it.": {"ru":"Если параметр \"Искать в подпапках\" включен, поиск будет производиться не только в указанной директории, но и рекурсивно по всем папкам которые в ней находятся."},
		"If the \"Append file\" option is disabled, the new data will overwrite the data already in the file, or will be written to a new file if the file does not already exist.": {"ru":"Если параметр \"Дописывать файл\" отключен, новые данные перезапишут данным, уже находящиеся в файле, или будут записаны в новый файл, если файл ещё не существует."},
		"If the \"Append file\" option is enabled, the new data will be added to the data already in the file, or will be written to a new file if the file does not already exist.": {"ru":"Если параметр \"Дописывать файл\" включен, новые данные будут добавлены к данным, уже находящимся в файле, или будут записаны в новый файл, если файл ещё не существует."},
		"Each action except this and \"Close connection\" open new or uses an already opened connection. The connection is automatically closed by timeout if it is not used.": {"ru":"Каждое действие кроме этого и \"Закрыть соединение\" открывает новое или использует уже открытое соединение. Соединение автоматически закрывается по таймауту если оно не используется."},
		"If \"Search in subfolders\" option is enabled, the search can take a long time, so it is better to increase the action timeout by clicking on the hourglass next to the cancel button.": {"ru":"Если параметр \"Искать в подпапках\" включен, поиск может занимать много времени, поэтому лучше увеличить таймаут действия, нажав на песочные часы рядом с кнопкой отмены."},
		"Variable in which, after successful execution of the action, the list of found files/folders will be written. The list will contain not only the names of files/folders, but their full path.": {"ru":"Переменная в которую, после успешного выполнения действия, будет записан список найденных файлов/папок. Список будет содержать не только названия файлов/папок, но их полный путь."},
        "SSH (Secure Shell) allows to execute commands and transfer files on remote VPS or VDS. Every connection is encrypted. When you rent a remote Linux server, hosting always provides SSH access.":{"ru":"SSH (Secure Shell) позволяет выполнять команды и передавать файлы на удаленный VPS или VDS. Каждое соединение зашифровано. Когда вы арендуете удаленный Linux сервер, хостинг всегда предоставляет доступ по SSH."},
		"FTP (File Transfer Protocol) is a standard network protocol used to transfer files between a client and a server. If you have VPS or VDS, you need to install FTP server first in order to use FTP connection type.": {"ru":"FTP (File Transfer Protocol) — это стандартный сетевой протокол, используемый для передачи файлов между клиентом и сервером. Если у вас есть VPS или VDS сервер, вам необходимо сначала установить FTP сервер, чтобы использовать протокол FTP."},
        "This action won't start connection, it only sets configuration. Connection will be established after first attempt to access server. When action, which triggers connection will be finished, connection won't be closed immediately. It will be preserved for a time specified in this parameter. If another action will require access to server, connection will be reused.": {"ru":"Это действие не устанавливает соединение сразу. Соединение будет установлено только после первой попытки доступа к серверу. Когда действие, запускающее соединение, будет завершено, соединение не будет закрыто. Оно будет храниться в течение времени, указанного в этом параметре. Если другое действие снова потребует доступа к серверу, соединение будет повторно использовано."},
        "This action won't start connection, it only sets configuration. Connection will be established after first attempt to access server. When action, which triggers connection will be finished, connection won't be closed immediately. It will be preserved for a time specified in \"Timeout\" parameter. If another action will require access to server, connection will be reused.": {"ru":"Это действие не устанавливает соединение сразу. Соединение будет установлено только после первой попытки доступа к серверу. Когда действие, запускающее соединение, будет завершено, соединение не будет закрыто. Оно будет храниться в течение времени, указанного в параметре \"Таймаут\". Если другое действие снова потребует доступа к серверу, соединение будет повторно использовано."}
    },
    "major_version": 1,
    "minor_version": 1,
    "modules": [
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "ftp",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "ssh2-sftp-client",
            "ModuleVersion": "*"
        },
        {
            "LanguageName": "Node",
            "LanguageVersion": "12.18.3",
            "ModuleName": "ssh2",
            "ModuleVersion": "*"
        }
    ],
    "name": "FTP"
}
